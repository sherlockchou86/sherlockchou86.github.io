<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VideoPipe: cereal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">VideoPipe
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">cereal Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>in certain simple scenarios. They should probably not be used if maximizing performance is the main objective.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecereal_1_1base64" id="r_namespacecereal_1_1base64"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1base64.html">base64</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1base__class__detail" id="r_namespacecereal_1_1base__class__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1base__class__detail.html">base_class_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1bitset__detail" id="r_namespacecereal_1_1bitset__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1bitset__detail.html">bitset_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1boost__variant__detail" id="r_namespacecereal_1_1boost__variant__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1boost__variant__detail.html">boost_variant_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1common__detail" id="r_namespacecereal_1_1common__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1common__detail.html">common_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1detail" id="r_namespacecereal_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1memory__detail" id="r_namespacecereal_1_1memory__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1memory__detail.html">memory_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1polymorphic__detail" id="r_namespacecereal_1_1polymorphic__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1polymorphic__detail.html">polymorphic_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1portable__binary__detail" id="r_namespacecereal_1_1portable__binary__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1portable__binary__detail.html">portable_binary_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1queue__detail" id="r_namespacecereal_1_1queue__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1queue__detail.html">queue_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1rapidxml" id="r_namespacecereal_1_1rapidxml"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1rapidxml.html">rapidxml</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1set__detail" id="r_namespacecereal_1_1set__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1set__detail.html">set_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1stack__detail" id="r_namespacecereal_1_1stack__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1stack__detail.html">stack_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1traits" id="r_namespacecereal_1_1traits"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1traits.html">traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1tuple__detail" id="r_namespacecereal_1_1tuple__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1tuple__detail.html">tuple_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1unordered__set__detail" id="r_namespacecereal_1_1unordered__set__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1unordered__set__detail.html">unordered_set_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1util" id="r_namespacecereal_1_1util"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1util.html">util</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1variant__detail" id="r_namespacecereal_1_1variant__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1variant__detail.html">variant_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecereal_1_1xml__detail" id="r_namespacecereal_1_1xml__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecereal_1_1xml__detail.html">xml_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1access.html">access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that can be made a friend to give cereal access to non public functions.  <a href="classcereal_1_1access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1base__class.html">base_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a derived class to its non-virtual base class in a way that safely supports abstract classes.  <a href="structcereal_1_1base__class.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around data that can be serialized in a binary fashion.  <a href="structcereal_1_1_binary_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_binary_input_archive.html">BinaryInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input archive designed to load data saved using <a class="el" href="classcereal_1_1_binary_output_archive.html" title="An output archive designed to save data in a compact binary representation.">BinaryOutputArchive</a>.  <a href="classcereal_1_1_binary_input_archive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_binary_output_archive.html">BinaryOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data in a compact binary representation.  <a href="classcereal_1_1_binary_output_archive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1construct.html">construct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to construct types with no default constructor.  <a href="classcereal_1_1construct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around data that should be serialized after all non-deferred data.  <a href="classcereal_1_1_deferred_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1_exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception class thrown when things go wrong at runtime.  <a href="structcereal_1_1_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_input_archive.html">InputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base input archive class.  <a href="classcereal_1_1_input_archive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input archive designed to load data from JSON.  <a href="classcereal_1_1_j_s_o_n_input_archive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data to JSON.  <a href="classcereal_1_1_j_s_o_n_output_archive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1_load_and_construct.html">LoadAndConstruct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that allows cereal to load smart pointers to types that have no default constructor.  <a href="structcereal_1_1_load_and_construct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1_map_item.html">MapItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around a key and value for serializing data into maps.  <a href="structcereal_1_1_map_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For holding name value pairs.  <a href="classcereal_1_1_name_value_pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_output_archive.html">OutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base output archive class.  <a href="classcereal_1_1_output_archive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_portable_binary_input_archive.html">PortableBinaryInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An input archive designed to load data saved using <a class="el" href="classcereal_1_1_portable_binary_output_archive.html" title="An output archive designed to save data in a compact binary representation portable over different ar...">PortableBinaryOutputArchive</a>.  <a href="classcereal_1_1_portable_binary_input_archive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_portable_binary_output_archive.html">PortableBinaryOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data in a compact binary representation portable over different architectures.  <a href="classcereal_1_1_portable_binary_output_archive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1_rapid_j_s_o_n_exception.html">RapidJSONException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception thrown when rapidjson fails an internal assertion.  <a href="structcereal_1_1_rapid_j_s_o_n_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around size metadata.  <a href="classcereal_1_1_size_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1specialize.html">specialize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used to disambiguate cases where cereal cannot detect a unique way of serializing a class.  <a href="structcereal_1_1specialize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1virtual__base__class.html">virtual_base_class</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a derived class to its virtual base class in a way that allows cereal to track inheritance.  <a href="structcereal_1_1virtual__base__class.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to load data from XML.  <a href="classcereal_1_1_x_m_l_input_archive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An output archive designed to save data to XML.  <a href="classcereal_1_1_x_m_l_output_archive.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0e01d80aaafe0efb12b75abdee310ae4" id="r_a0e01d80aaafe0efb12b75abdee310ae4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e01d80aaafe0efb12b75abdee310ae4">size_type</a> = <a class="el" href="macros_8hpp.html#a2ad098b163a5f4829eb00fd7fb0b408d">CEREAL_SIZE_TYPE</a></td></tr>
<tr class="memdesc:a0e01d80aaafe0efb12b75abdee310ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size type used by cereal.  <br /></td></tr>
<tr class="separator:a0e01d80aaafe0efb12b75abdee310ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a95185aa9f39e4ac382bb6631beb68a67" id="r_a95185aa9f39e4ac382bb6631beb68a67"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95185aa9f39e4ac382bb6631beb68a67">Flags</a> { <a class="el" href="#a95185aa9f39e4ac382bb6631beb68a67ae264e38ef1170510fbdfa5f1e4d5c532">AllowEmptyClassElision</a> = 1
 }</td></tr>
<tr class="memdesc:a95185aa9f39e4ac382bb6631beb68a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special flags for archives.  <a href="#a95185aa9f39e4ac382bb6631beb68a67">More...</a><br /></td></tr>
<tr class="separator:a95185aa9f39e4ac382bb6631beb68a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28bb730353e53b3066cc679e63bb108" id="r_ac28bb730353e53b3066cc679e63bb108"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1specialize.html#ac28bb730353e53b3066cc679e63bb108">specialization</a> </td></tr>
<tr class="separator:ac28bb730353e53b3066cc679e63bb108"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2287a243ece679a7cfad54641c790ecc" id="r_a2287a243ece679a7cfad54641c790ecc"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2287a243ece679a7cfad54641c790ecc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2287a243ece679a7cfad54641c790ecc">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_binary_output_archive.html">BinaryOutputArchive</a> &amp;ar, T const &amp;t)</td></tr>
<tr class="memdesc:a2287a243ece679a7cfad54641c790ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for POD types to binary.  <br /></td></tr>
<tr class="separator:a2287a243ece679a7cfad54641c790ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960b7971cfb99b3c826258369bfc01e9" id="r_a960b7971cfb99b3c826258369bfc01e9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a960b7971cfb99b3c826258369bfc01e9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a960b7971cfb99b3c826258369bfc01e9">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_binary_input_archive.html">BinaryInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:a960b7971cfb99b3c826258369bfc01e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for POD types from binary.  <br /></td></tr>
<tr class="separator:a960b7971cfb99b3c826258369bfc01e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ec0a04e5dc57a58de5e78b5a87b8d3" id="r_a64ec0a04e5dc57a58de5e78b5a87b8d3"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a64ec0a04e5dc57a58de5e78b5a87b8d3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a64ec0a04e5dc57a58de5e78b5a87b8d3">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:a64ec0a04e5dc57a58de5e78b5a87b8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing NVP types to binary.  <br /></td></tr>
<tr class="separator:a64ec0a04e5dc57a58de5e78b5a87b8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fb9b1468920e7e23cb2817e65fed4a" id="r_ac5fb9b1468920e7e23cb2817e65fed4a"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ac5fb9b1468920e7e23cb2817e65fed4a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac5fb9b1468920e7e23cb2817e65fed4a">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ac5fb9b1468920e7e23cb2817e65fed4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing SizeTags to binary.  <br /></td></tr>
<tr class="separator:ac5fb9b1468920e7e23cb2817e65fed4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a189662781a0f3b710901f892d87792d5" id="r_a189662781a0f3b710901f892d87792d5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a189662781a0f3b710901f892d87792d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a189662781a0f3b710901f892d87792d5">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_binary_output_archive.html">BinaryOutputArchive</a> &amp;ar, <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt; const &amp;bd)</td></tr>
<tr class="memdesc:a189662781a0f3b710901f892d87792d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving binary data.  <br /></td></tr>
<tr class="separator:a189662781a0f3b710901f892d87792d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8577c2834d64922e9460cad77f9a3ac" id="r_af8577c2834d64922e9460cad77f9a3ac"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af8577c2834d64922e9460cad77f9a3ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af8577c2834d64922e9460cad77f9a3ac">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_binary_input_archive.html">BinaryInputArchive</a> &amp;ar, <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt; &amp;bd)</td></tr>
<tr class="memdesc:af8577c2834d64922e9460cad77f9a3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading binary data.  <br /></td></tr>
<tr class="separator:af8577c2834d64922e9460cad77f9a3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac267b8915a13f4433fc25aa9d310ee40" id="r_ac267b8915a13f4433fc25aa9d310ee40"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac267b8915a13f4433fc25aa9d310ee40"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac267b8915a13f4433fc25aa9d310ee40">prologue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ac267b8915a13f4433fc25aa9d310ee40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for JSON archives.  <br /></td></tr>
<tr class="separator:ac267b8915a13f4433fc25aa9d310ee40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77f745fd34dd83fa6543e0fa478bdfa" id="r_ae77f745fd34dd83fa6543e0fa478bdfa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae77f745fd34dd83fa6543e0fa478bdfa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae77f745fd34dd83fa6543e0fa478bdfa">prologue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ae77f745fd34dd83fa6543e0fa478bdfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for JSON archives.  <br /></td></tr>
<tr class="separator:ae77f745fd34dd83fa6543e0fa478bdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bec173adc6146ecc712921c2d257ade" id="r_a3bec173adc6146ecc712921c2d257ade"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3bec173adc6146ecc712921c2d257ade"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3bec173adc6146ecc712921c2d257ade">epilogue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a3bec173adc6146ecc712921c2d257ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for JSON archives.  <br /></td></tr>
<tr class="separator:a3bec173adc6146ecc712921c2d257ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99326c431920835d61e5bfc51b865f22" id="r_a99326c431920835d61e5bfc51b865f22"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a99326c431920835d61e5bfc51b865f22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a99326c431920835d61e5bfc51b865f22">epilogue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a99326c431920835d61e5bfc51b865f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for JSON archives.  <br /></td></tr>
<tr class="separator:a99326c431920835d61e5bfc51b865f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4eb0997ec3815e2be77c35351d02cf7" id="r_ab4eb0997ec3815e2be77c35351d02cf7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab4eb0997ec3815e2be77c35351d02cf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab4eb0997ec3815e2be77c35351d02cf7">prologue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ab4eb0997ec3815e2be77c35351d02cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for deferred data for JSON archives.  <br /></td></tr>
<tr class="separator:ab4eb0997ec3815e2be77c35351d02cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff01a6c38b02073beb88b56f80b0ba7" id="r_a6ff01a6c38b02073beb88b56f80b0ba7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6ff01a6c38b02073beb88b56f80b0ba7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ff01a6c38b02073beb88b56f80b0ba7">prologue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a6ff01a6c38b02073beb88b56f80b0ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for deferred data for JSON archives.  <br /></td></tr>
<tr class="separator:a6ff01a6c38b02073beb88b56f80b0ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c0c3b1ea7aadc84af34b815bfad6a6" id="r_ae0c0c3b1ea7aadc84af34b815bfad6a6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae0c0c3b1ea7aadc84af34b815bfad6a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae0c0c3b1ea7aadc84af34b815bfad6a6">epilogue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ae0c0c3b1ea7aadc84af34b815bfad6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for deferred for JSON archives.  <br /></td></tr>
<tr class="separator:ae0c0c3b1ea7aadc84af34b815bfad6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae425e0a66c44b7d39b16d0a6a7f0d9" id="r_a7ae425e0a66c44b7d39b16d0a6a7f0d9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7ae425e0a66c44b7d39b16d0a6a7f0d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ae425e0a66c44b7d39b16d0a6a7f0d9">epilogue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a7ae425e0a66c44b7d39b16d0a6a7f0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for deferred for JSON archives.  <br /></td></tr>
<tr class="separator:a7ae425e0a66c44b7d39b16d0a6a7f0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7ec98da774f9e0af596620859d8ccb" id="r_a5f7ec98da774f9e0af596620859d8ccb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5f7ec98da774f9e0af596620859d8ccb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5f7ec98da774f9e0af596620859d8ccb">prologue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a5f7ec98da774f9e0af596620859d8ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for SizeTags for JSON archives.  <br /></td></tr>
<tr class="separator:a5f7ec98da774f9e0af596620859d8ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accec39647fd17ad5470e42a5c371701c" id="r_accec39647fd17ad5470e42a5c371701c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:accec39647fd17ad5470e42a5c371701c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#accec39647fd17ad5470e42a5c371701c">prologue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:accec39647fd17ad5470e42a5c371701c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for SizeTags for JSON archives.  <br /></td></tr>
<tr class="separator:accec39647fd17ad5470e42a5c371701c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92526cf5d3f4a642d918a027d2e4567" id="r_ab92526cf5d3f4a642d918a027d2e4567"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab92526cf5d3f4a642d918a027d2e4567"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab92526cf5d3f4a642d918a027d2e4567">epilogue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ab92526cf5d3f4a642d918a027d2e4567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for SizeTags for JSON archives.  <br /></td></tr>
<tr class="separator:ab92526cf5d3f4a642d918a027d2e4567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb582097a98c0558c1a6b3cf0ef52270" id="r_acb582097a98c0558c1a6b3cf0ef52270"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acb582097a98c0558c1a6b3cf0ef52270"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acb582097a98c0558c1a6b3cf0ef52270">epilogue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, <a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:acb582097a98c0558c1a6b3cf0ef52270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for SizeTags for JSON archives.  <br /></td></tr>
<tr class="separator:acb582097a98c0558c1a6b3cf0ef52270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2924cd871a88c20023171f74a68d39" id="r_aba2924cd871a88c20023171f74a68d39"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:aba2924cd871a88c20023171f74a68d39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba2924cd871a88c20023171f74a68d39">prologue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:aba2924cd871a88c20023171f74a68d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for JSON archives (except minimal types)  <br /></td></tr>
<tr class="separator:aba2924cd871a88c20023171f74a68d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88fce78fe97297ab4d22a607fee1e07" id="r_af88fce78fe97297ab4d22a607fee1e07"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>, <a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:af88fce78fe97297ab4d22a607fee1e07"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af88fce78fe97297ab4d22a607fee1e07">prologue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:af88fce78fe97297ab4d22a607fee1e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for JSON archives.  <br /></td></tr>
<tr class="separator:af88fce78fe97297ab4d22a607fee1e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6adc568591c0a525f2c16ea5912c5b" id="r_abb6adc568591c0a525f2c16ea5912c5b"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:abb6adc568591c0a525f2c16ea5912c5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abb6adc568591c0a525f2c16ea5912c5b">epilogue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:abb6adc568591c0a525f2c16ea5912c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for JSON archives (except minimal types)  <br /></td></tr>
<tr class="separator:abb6adc568591c0a525f2c16ea5912c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdc10b14dce9340a8df6cb18ac74554" id="r_a5cdc10b14dce9340a8df6cb18ac74554"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>, <a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a5cdc10b14dce9340a8df6cb18ac74554"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5cdc10b14dce9340a8df6cb18ac74554">epilogue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:a5cdc10b14dce9340a8df6cb18ac74554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for JSON archives.  <br /></td></tr>
<tr class="separator:a5cdc10b14dce9340a8df6cb18ac74554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956c4c0578baf265811497c965c4a382" id="r_a956c4c0578baf265811497c965c4a382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a956c4c0578baf265811497c965c4a382">prologue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, std::nullptr_t const &amp;)</td></tr>
<tr class="memdesc:a956c4c0578baf265811497c965c4a382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for arithmetic types for JSON archives.  <br /></td></tr>
<tr class="separator:a956c4c0578baf265811497c965c4a382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef075a9d94a926df8ba17689914233e2" id="r_aef075a9d94a926df8ba17689914233e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef075a9d94a926df8ba17689914233e2">prologue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, std::nullptr_t const &amp;)</td></tr>
<tr class="memdesc:aef075a9d94a926df8ba17689914233e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for arithmetic types for JSON archives.  <br /></td></tr>
<tr class="separator:aef075a9d94a926df8ba17689914233e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67f92a71f4318dd69e6dec516fe57dd" id="r_ad67f92a71f4318dd69e6dec516fe57dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad67f92a71f4318dd69e6dec516fe57dd">epilogue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, std::nullptr_t const &amp;)</td></tr>
<tr class="memdesc:ad67f92a71f4318dd69e6dec516fe57dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for arithmetic types for JSON archives.  <br /></td></tr>
<tr class="separator:ad67f92a71f4318dd69e6dec516fe57dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9198bda1f28453a9ead2f8999e5fb449" id="r_a9198bda1f28453a9ead2f8999e5fb449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9198bda1f28453a9ead2f8999e5fb449">epilogue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, std::nullptr_t const &amp;)</td></tr>
<tr class="memdesc:a9198bda1f28453a9ead2f8999e5fb449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for arithmetic types for JSON archives.  <br /></td></tr>
<tr class="separator:a9198bda1f28453a9ead2f8999e5fb449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacd1c15f7ed1793453e56a675bd0a78" id="r_adacd1c15f7ed1793453e56a675bd0a78"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:adacd1c15f7ed1793453e56a675bd0a78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adacd1c15f7ed1793453e56a675bd0a78">prologue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;)</td></tr>
<tr class="memdesc:adacd1c15f7ed1793453e56a675bd0a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for strings for JSON archives.  <br /></td></tr>
<tr class="separator:adacd1c15f7ed1793453e56a675bd0a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dde17944a1c24885e39ff673b402841" id="r_a4dde17944a1c24885e39ff673b402841"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a4dde17944a1c24885e39ff673b402841"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4dde17944a1c24885e39ff673b402841">prologue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;)</td></tr>
<tr class="memdesc:a4dde17944a1c24885e39ff673b402841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for strings for JSON archives.  <br /></td></tr>
<tr class="separator:a4dde17944a1c24885e39ff673b402841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06f0f66ced9dd9c85377ba61054df94" id="r_aa06f0f66ced9dd9c85377ba61054df94"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:aa06f0f66ced9dd9c85377ba61054df94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa06f0f66ced9dd9c85377ba61054df94">epilogue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;)</td></tr>
<tr class="memdesc:aa06f0f66ced9dd9c85377ba61054df94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for strings for JSON archives.  <br /></td></tr>
<tr class="separator:aa06f0f66ced9dd9c85377ba61054df94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733225f7be628b7c4dfca463d6a44253" id="r_a733225f7be628b7c4dfca463d6a44253"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a733225f7be628b7c4dfca463d6a44253"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a733225f7be628b7c4dfca463d6a44253">epilogue</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;)</td></tr>
<tr class="memdesc:a733225f7be628b7c4dfca463d6a44253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for strings for JSON archives.  <br /></td></tr>
<tr class="separator:a733225f7be628b7c4dfca463d6a44253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049f4acf75e647cce18b4b98c9037cfb" id="r_a049f4acf75e647cce18b4b98c9037cfb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a049f4acf75e647cce18b4b98c9037cfb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a049f4acf75e647cce18b4b98c9037cfb">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="memdesc:a049f4acf75e647cce18b4b98c9037cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing NVP types to JSON.  <br /></td></tr>
<tr class="separator:a049f4acf75e647cce18b4b98c9037cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42319b92c41f6f15a86b69fcd87246d2" id="r_a42319b92c41f6f15a86b69fcd87246d2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a42319b92c41f6f15a86b69fcd87246d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a42319b92c41f6f15a86b69fcd87246d2">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="separator:a42319b92c41f6f15a86b69fcd87246d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05ab834a18302c852181802b22d30ec" id="r_ad05ab834a18302c852181802b22d30ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad05ab834a18302c852181802b22d30ec">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, std::nullptr_t const &amp;t)</td></tr>
<tr class="memdesc:ad05ab834a18302c852181802b22d30ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for nullptr to JSON.  <br /></td></tr>
<tr class="separator:ad05ab834a18302c852181802b22d30ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7f1f974a532bbad87a7b4d8fe746e8" id="r_aed7f1f974a532bbad87a7b4d8fe746e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed7f1f974a532bbad87a7b4d8fe746e8">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;ar, std::nullptr_t &amp;t)</td></tr>
<tr class="memdesc:aed7f1f974a532bbad87a7b4d8fe746e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading arithmetic from JSON.  <br /></td></tr>
<tr class="separator:aed7f1f974a532bbad87a7b4d8fe746e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272e0c7b90d4591e8e0a13ebb17ca909" id="r_a272e0c7b90d4591e8e0a13ebb17ca909"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a272e0c7b90d4591e8e0a13ebb17ca909"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a272e0c7b90d4591e8e0a13ebb17ca909">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, T const &amp;t)</td></tr>
<tr class="memdesc:a272e0c7b90d4591e8e0a13ebb17ca909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for arithmetic to JSON.  <br /></td></tr>
<tr class="separator:a272e0c7b90d4591e8e0a13ebb17ca909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f34376d3320a6fd7be58df311bd961" id="r_af0f34376d3320a6fd7be58df311bd961"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:af0f34376d3320a6fd7be58df311bd961"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af0f34376d3320a6fd7be58df311bd961">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:af0f34376d3320a6fd7be58df311bd961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading arithmetic from JSON.  <br /></td></tr>
<tr class="separator:af0f34376d3320a6fd7be58df311bd961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cbcd5c53fd79f0f97b816820b013ff" id="r_a94cbcd5c53fd79f0f97b816820b013ff"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a94cbcd5c53fd79f0f97b816820b013ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a94cbcd5c53fd79f0f97b816820b013ff">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;str)</td></tr>
<tr class="memdesc:a94cbcd5c53fd79f0f97b816820b013ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">saving string to JSON  <br /></td></tr>
<tr class="separator:a94cbcd5c53fd79f0f97b816820b013ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9afcaeb51833d26e15a78d55e5ae30" id="r_a8a9afcaeb51833d26e15a78d55e5ae30"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a8a9afcaeb51833d26e15a78d55e5ae30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8a9afcaeb51833d26e15a78d55e5ae30">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;str)</td></tr>
<tr class="memdesc:a8a9afcaeb51833d26e15a78d55e5ae30"><td class="mdescLeft">&#160;</td><td class="mdescRight">loading string from JSON  <br /></td></tr>
<tr class="separator:a8a9afcaeb51833d26e15a78d55e5ae30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b30facce64dd6f270097f144f9ffde" id="r_a66b30facce64dd6f270097f144f9ffde"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a66b30facce64dd6f270097f144f9ffde"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a66b30facce64dd6f270097f144f9ffde">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a66b30facce64dd6f270097f144f9ffde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving SizeTags to JSON.  <br /></td></tr>
<tr class="separator:a66b30facce64dd6f270097f144f9ffde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e7a02ebbdcca274a8c905878725057" id="r_ab8e7a02ebbdcca274a8c905878725057"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab8e7a02ebbdcca274a8c905878725057"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8e7a02ebbdcca274a8c905878725057">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; &amp;st)</td></tr>
<tr class="memdesc:ab8e7a02ebbdcca274a8c905878725057"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading SizeTags from JSON.  <br /></td></tr>
<tr class="separator:ab8e7a02ebbdcca274a8c905878725057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a82fca196f0aaac88c78a46ab52475" id="r_aa2a82fca196f0aaac88c78a46ab52475"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa2a82fca196f0aaac88c78a46ab52475"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa2a82fca196f0aaac88c78a46ab52475">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_portable_binary_output_archive.html">PortableBinaryOutputArchive</a> &amp;ar, T const &amp;t)</td></tr>
<tr class="memdesc:aa2a82fca196f0aaac88c78a46ab52475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for POD types to portable binary.  <br /></td></tr>
<tr class="separator:aa2a82fca196f0aaac88c78a46ab52475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8969743ff3cd671810d314350f4d4a8a" id="r_a8969743ff3cd671810d314350f4d4a8a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8969743ff3cd671810d314350f4d4a8a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8969743ff3cd671810d314350f4d4a8a">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_portable_binary_input_archive.html">PortableBinaryInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:a8969743ff3cd671810d314350f4d4a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for POD types from portable binary.  <br /></td></tr>
<tr class="separator:a8969743ff3cd671810d314350f4d4a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba55a1d28e2db9a09ba767a4b1f16d7" id="r_a4ba55a1d28e2db9a09ba767a4b1f16d7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4ba55a1d28e2db9a09ba767a4b1f16d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ba55a1d28e2db9a09ba767a4b1f16d7">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_portable_binary_output_archive.html">PortableBinaryOutputArchive</a> &amp;ar, <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt; const &amp;bd)</td></tr>
<tr class="memdesc:a4ba55a1d28e2db9a09ba767a4b1f16d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving binary data to portable binary.  <br /></td></tr>
<tr class="separator:a4ba55a1d28e2db9a09ba767a4b1f16d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10780060393e472b72fb4a2158d641ec" id="r_a10780060393e472b72fb4a2158d641ec"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a10780060393e472b72fb4a2158d641ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a10780060393e472b72fb4a2158d641ec">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_portable_binary_input_archive.html">PortableBinaryInputArchive</a> &amp;ar, <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt; &amp;bd)</td></tr>
<tr class="memdesc:a10780060393e472b72fb4a2158d641ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading binary data from portable binary.  <br /></td></tr>
<tr class="separator:a10780060393e472b72fb4a2158d641ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2582cc8477f9482910fc5733e13f75f7" id="r_a2582cc8477f9482910fc5733e13f75f7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2582cc8477f9482910fc5733e13f75f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2582cc8477f9482910fc5733e13f75f7">prologue</a> (<a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a2582cc8477f9482910fc5733e13f75f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for XML output archives.  <br /></td></tr>
<tr class="separator:a2582cc8477f9482910fc5733e13f75f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06224101dfaf6979418326a7664e13e2" id="r_a06224101dfaf6979418326a7664e13e2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a06224101dfaf6979418326a7664e13e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06224101dfaf6979418326a7664e13e2">prologue</a> (<a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a06224101dfaf6979418326a7664e13e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for NVPs for XML input archives.  <br /></td></tr>
<tr class="separator:a06224101dfaf6979418326a7664e13e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906ef65c3ab455598f768431bcd5f37d" id="r_a906ef65c3ab455598f768431bcd5f37d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a906ef65c3ab455598f768431bcd5f37d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a906ef65c3ab455598f768431bcd5f37d">epilogue</a> (<a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a906ef65c3ab455598f768431bcd5f37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for XML output archives.  <br /></td></tr>
<tr class="separator:a906ef65c3ab455598f768431bcd5f37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1af5fa5a466ad0cd89513aab823b80" id="r_a5d1af5fa5a466ad0cd89513aab823b80"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5d1af5fa5a466ad0cd89513aab823b80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5d1af5fa5a466ad0cd89513aab823b80">epilogue</a> (<a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a5d1af5fa5a466ad0cd89513aab823b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for NVPs for XML input archives.  <br /></td></tr>
<tr class="separator:a5d1af5fa5a466ad0cd89513aab823b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6124c7acd34d3740cbedd39559da73c3" id="r_a6124c7acd34d3740cbedd39559da73c3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6124c7acd34d3740cbedd39559da73c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6124c7acd34d3740cbedd39559da73c3">prologue</a> (<a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a6124c7acd34d3740cbedd39559da73c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for deferred data for XML archives.  <br /></td></tr>
<tr class="separator:a6124c7acd34d3740cbedd39559da73c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf285317856bf80daaa225e171d8d951" id="r_adf285317856bf80daaa225e171d8d951"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adf285317856bf80daaa225e171d8d951"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adf285317856bf80daaa225e171d8d951">prologue</a> (<a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:adf285317856bf80daaa225e171d8d951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for deferred data for XML archives.  <br /></td></tr>
<tr class="separator:adf285317856bf80daaa225e171d8d951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1f17a3cae999a9be34889fd2c509a0" id="r_acb1f17a3cae999a9be34889fd2c509a0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acb1f17a3cae999a9be34889fd2c509a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acb1f17a3cae999a9be34889fd2c509a0">epilogue</a> (<a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:acb1f17a3cae999a9be34889fd2c509a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for deferred for XML archives.  <br /></td></tr>
<tr class="separator:acb1f17a3cae999a9be34889fd2c509a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bbce1604367ea45c07dc677186ed64" id="r_a70bbce1604367ea45c07dc677186ed64"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a70bbce1604367ea45c07dc677186ed64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a70bbce1604367ea45c07dc677186ed64">epilogue</a> (<a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a70bbce1604367ea45c07dc677186ed64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for deferred for XML archives.  <br /></td></tr>
<tr class="separator:a70bbce1604367ea45c07dc677186ed64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb541e9594201d78a04cb11ad806ba0" id="r_adbb541e9594201d78a04cb11ad806ba0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adbb541e9594201d78a04cb11ad806ba0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adbb541e9594201d78a04cb11ad806ba0">prologue</a> (<a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:adbb541e9594201d78a04cb11ad806ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for SizeTags for XML output archives.  <br /></td></tr>
<tr class="separator:adbb541e9594201d78a04cb11ad806ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25e6485f450649b931e07e0f6384a76" id="r_aa25e6485f450649b931e07e0f6384a76"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa25e6485f450649b931e07e0f6384a76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa25e6485f450649b931e07e0f6384a76">prologue</a> (<a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="separator:aa25e6485f450649b931e07e0f6384a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3700f36066026da589faa60fed7ca53" id="r_ac3700f36066026da589faa60fed7ca53"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac3700f36066026da589faa60fed7ca53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac3700f36066026da589faa60fed7ca53">epilogue</a> (<a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:ac3700f36066026da589faa60fed7ca53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for SizeTags for XML output archives.  <br /></td></tr>
<tr class="separator:ac3700f36066026da589faa60fed7ca53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada513bbfcf8c1996e6f7a439f129a208" id="r_ada513bbfcf8c1996e6f7a439f129a208"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ada513bbfcf8c1996e6f7a439f129a208"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada513bbfcf8c1996e6f7a439f129a208">epilogue</a> (<a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;, <a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="separator:ada513bbfcf8c1996e6f7a439f129a208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af751c02a4443b571fee21416a4b899c1" id="r_af751c02a4443b571fee21416a4b899c1"><td class="memTemplParams" colspan="2">template&lt;class T , traits::DisableIf&lt; <a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||<a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:af751c02a4443b571fee21416a4b899c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af751c02a4443b571fee21416a4b899c1">prologue</a> (<a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:af751c02a4443b571fee21416a4b899c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for XML output archives (except minimal types)  <br /></td></tr>
<tr class="separator:af751c02a4443b571fee21416a4b899c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea2b824c9d003b9e2b36473db1d22c0" id="r_a7ea2b824c9d003b9e2b36473db1d22c0"><td class="memTemplParams" colspan="2">template&lt;class T , traits::DisableIf&lt; <a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>, <a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||<a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a7ea2b824c9d003b9e2b36473db1d22c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7ea2b824c9d003b9e2b36473db1d22c0">prologue</a> (<a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:a7ea2b824c9d003b9e2b36473db1d22c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prologue for all other types for XML input archives (except minimal types)  <br /></td></tr>
<tr class="separator:a7ea2b824c9d003b9e2b36473db1d22c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ca55f7d5556527de1584198ea3c414" id="r_a16ca55f7d5556527de1584198ea3c414"><td class="memTemplParams" colspan="2">template&lt;class T , traits::DisableIf&lt; <a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||<a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a16ca55f7d5556527de1584198ea3c414"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a16ca55f7d5556527de1584198ea3c414">epilogue</a> (<a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:a16ca55f7d5556527de1584198ea3c414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for XML output archives (except minimal types)  <br /></td></tr>
<tr class="separator:a16ca55f7d5556527de1584198ea3c414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06e3f89a66231db109db984a87e0cfd" id="r_ae06e3f89a66231db109db984a87e0cfd"><td class="memTemplParams" colspan="2">template&lt;class T , traits::DisableIf&lt; <a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>, <a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||<a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:ae06e3f89a66231db109db984a87e0cfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae06e3f89a66231db109db984a87e0cfd">epilogue</a> (<a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;ar, T const &amp;)</td></tr>
<tr class="memdesc:ae06e3f89a66231db109db984a87e0cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Epilogue for all other types other for XML output archives (except minimal types)  <br /></td></tr>
<tr class="separator:ae06e3f89a66231db109db984a87e0cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a252f7731760e1186c3c552f640fc7b" id="r_a9a252f7731760e1186c3c552f640fc7b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9a252f7731760e1186c3c552f640fc7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9a252f7731760e1186c3c552f640fc7b">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;t)</td></tr>
<tr class="memdesc:a9a252f7731760e1186c3c552f640fc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving NVP types to XML.  <br /></td></tr>
<tr class="separator:a9a252f7731760e1186c3c552f640fc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a08767af52642e109545f05a4694380" id="r_a0a08767af52642e109545f05a4694380"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0a08767af52642e109545f05a4694380"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a08767af52642e109545f05a4694380">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:a0a08767af52642e109545f05a4694380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading NVP types from XML.  <br /></td></tr>
<tr class="separator:a0a08767af52642e109545f05a4694380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1703ea149fc65a4d7851fa85823287b2" id="r_a1703ea149fc65a4d7851fa85823287b2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1703ea149fc65a4d7851fa85823287b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1703ea149fc65a4d7851fa85823287b2">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;, <a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;)</td></tr>
<tr class="memdesc:a1703ea149fc65a4d7851fa85823287b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving SizeTags to XML.  <br /></td></tr>
<tr class="separator:a1703ea149fc65a4d7851fa85823287b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88090838a4dbf54f907dee8969c0d5cf" id="r_a88090838a4dbf54f907dee8969c0d5cf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a88090838a4dbf54f907dee8969c0d5cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a88090838a4dbf54f907dee8969c0d5cf">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;ar, <a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; &amp;st)</td></tr>
<tr class="memdesc:a88090838a4dbf54f907dee8969c0d5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading SizeTags from XML.  <br /></td></tr>
<tr class="separator:a88090838a4dbf54f907dee8969c0d5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6311a745c3a12848550eff8fba71f31" id="r_ac6311a745c3a12848550eff8fba71f31"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:ac6311a745c3a12848550eff8fba71f31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac6311a745c3a12848550eff8fba71f31">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;ar, T const &amp;t)</td></tr>
<tr class="memdesc:ac6311a745c3a12848550eff8fba71f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for POD types to xml.  <br /></td></tr>
<tr class="separator:ac6311a745c3a12848550eff8fba71f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea476a67114d4998f2113da658c25468" id="r_aea476a67114d4998f2113da658c25468"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:aea476a67114d4998f2113da658c25468"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aea476a67114d4998f2113da658c25468">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;ar, T &amp;t)</td></tr>
<tr class="memdesc:aea476a67114d4998f2113da658c25468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for POD types from xml.  <br /></td></tr>
<tr class="separator:aea476a67114d4998f2113da658c25468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63696aa0de3dc95bc27f97bf455d15e8" id="r_a63696aa0de3dc95bc27f97bf455d15e8"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a63696aa0de3dc95bc27f97bf455d15e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a63696aa0de3dc95bc27f97bf455d15e8">CEREAL_SAVE_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;str)</td></tr>
<tr class="memdesc:a63696aa0de3dc95bc27f97bf455d15e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">saving string to xml  <br /></td></tr>
<tr class="separator:a63696aa0de3dc95bc27f97bf455d15e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5b214a91e6d61bcdae422e1cf27b37" id="r_a3f5b214a91e6d61bcdae422e1cf27b37"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a3f5b214a91e6d61bcdae422e1cf27b37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3f5b214a91e6d61bcdae422e1cf27b37">CEREAL_LOAD_FUNCTION_NAME</a> (<a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;str)</td></tr>
<tr class="memdesc:a3f5b214a91e6d61bcdae422e1cf27b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">loading string from xml  <br /></td></tr>
<tr class="separator:a3f5b214a91e6d61bcdae422e1cf27b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8093b5f7cfd618fae6350ef7b2c09453" id="r_a8093b5f7cfd618fae6350ef7b2c09453"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a8093b5f7cfd618fae6350ef7b2c09453"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8093b5f7cfd618fae6350ef7b2c09453">prologue</a> (Archive &amp;, T const &amp;)</td></tr>
<tr class="separator:a8093b5f7cfd618fae6350ef7b2c09453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1153b7ce7ffbb86e2c81e076a252938e" id="r_a1153b7ce7ffbb86e2c81e076a252938e"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a1153b7ce7ffbb86e2c81e076a252938e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1153b7ce7ffbb86e2c81e076a252938e">epilogue</a> (Archive &amp;, T const &amp;)</td></tr>
<tr class="separator:a1153b7ce7ffbb86e2c81e076a252938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72323b9f6443491b5fe35133c22b7060" id="r_a72323b9f6443491b5fe35133c22b7060"><td class="memTemplParams" colspan="2">template&lt;class KeyType , class ValueType &gt; </td></tr>
<tr class="memitem:a72323b9f6443491b5fe35133c22b7060"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcereal_1_1_map_item.html">MapItem</a>&lt; KeyType, ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72323b9f6443491b5fe35133c22b7060">make_map_item</a> (KeyType &amp;&amp;key, ValueType &amp;&amp;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a>)</td></tr>
<tr class="memdesc:a72323b9f6443491b5fe35133c22b7060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structcereal_1_1_map_item.html" title="A wrapper around a key and value for serializing data into maps.">MapItem</a> so that human readable archives will group keys and values together.  <br /></td></tr>
<tr class="separator:a72323b9f6443491b5fe35133c22b7060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c9c74df6d91319b01128690322690a" id="r_a54c9c74df6d91319b01128690322690a"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , size_t N&gt; </td></tr>
<tr class="memitem:a54c9c74df6d91319b01128690322690a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a54c9c74df6d91319b01128690322690a">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::array&lt; T, N &gt; const &amp;array)</td></tr>
<tr class="separator:a54c9c74df6d91319b01128690322690a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c962df81c2ad99813597b6238e3e17d" id="r_a5c962df81c2ad99813597b6238e3e17d"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , size_t N&gt; </td></tr>
<tr class="memitem:a5c962df81c2ad99813597b6238e3e17d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5c962df81c2ad99813597b6238e3e17d">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::array&lt; T, N &gt; &amp;array)</td></tr>
<tr class="separator:a5c962df81c2ad99813597b6238e3e17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668c4c41f5ca325091d5a357f89040c3" id="r_a668c4c41f5ca325091d5a357f89040c3"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , size_t N&gt; </td></tr>
<tr class="memitem:a668c4c41f5ca325091d5a357f89040c3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a668c4c41f5ca325091d5a357f89040c3">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::array&lt; T, N &gt; const &amp;array)</td></tr>
<tr class="memdesc:a668c4c41f5ca325091d5a357f89040c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::array all other types.  <br /></td></tr>
<tr class="separator:a668c4c41f5ca325091d5a357f89040c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1956f9852b727abcb5ee439dd8abf39" id="r_ad1956f9852b727abcb5ee439dd8abf39"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , size_t N&gt; </td></tr>
<tr class="memitem:ad1956f9852b727abcb5ee439dd8abf39"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad1956f9852b727abcb5ee439dd8abf39">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::array&lt; T, N &gt; &amp;array)</td></tr>
<tr class="memdesc:ad1956f9852b727abcb5ee439dd8abf39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::array all other types.  <br /></td></tr>
<tr class="separator:ad1956f9852b727abcb5ee439dd8abf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bab555e921d35f6f713b7e1cab187a" id="r_a99bab555e921d35f6f713b7e1cab187a"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a99bab555e921d35f6f713b7e1cab187a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a99bab555e921d35f6f713b7e1cab187a">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::atomic&lt; T &gt; const &amp;<a class="el" href="pointer_8h.html#aeeddce917cf130d62c370b8f216026dd">a</a>)</td></tr>
<tr class="memdesc:a99bab555e921d35f6f713b7e1cab187a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (save) for std::atomic.  <br /></td></tr>
<tr class="separator:a99bab555e921d35f6f713b7e1cab187a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc0336db29043e0f692517c77f9e7de" id="r_abfc0336db29043e0f692517c77f9e7de"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:abfc0336db29043e0f692517c77f9e7de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abfc0336db29043e0f692517c77f9e7de">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::atomic&lt; T &gt; &amp;<a class="el" href="pointer_8h.html#aeeddce917cf130d62c370b8f216026dd">a</a>)</td></tr>
<tr class="memdesc:abfc0336db29043e0f692517c77f9e7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (load) for std::atomic.  <br /></td></tr>
<tr class="separator:abfc0336db29043e0f692517c77f9e7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397c996c1b3e8bdcb3f43f11edf91126" id="r_a397c996c1b3e8bdcb3f43f11edf91126"><td class="memTemplParams" colspan="2">template&lt;class Archive , size_t N, traits::EnableIf&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; std::uint32_t &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:a397c996c1b3e8bdcb3f43f11edf91126"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a397c996c1b3e8bdcb3f43f11edf91126">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::bitset&lt; N &gt; const &amp;bits)</td></tr>
<tr class="memdesc:a397c996c1b3e8bdcb3f43f11edf91126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (save) for std::bitset when <a class="el" href="structcereal_1_1_binary_data.html" title="A wrapper around data that can be serialized in a binary fashion.">BinaryData</a> optimization supported.  <br /></td></tr>
<tr class="separator:a397c996c1b3e8bdcb3f43f11edf91126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cfa5e251b7a85343f0a92e93f50a60" id="r_ad8cfa5e251b7a85343f0a92e93f50a60"><td class="memTemplParams" colspan="2">template&lt;class Archive , size_t N&gt; </td></tr>
<tr class="memitem:ad8cfa5e251b7a85343f0a92e93f50a60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad8cfa5e251b7a85343f0a92e93f50a60">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::bitset&lt; N &gt; &amp;bits)</td></tr>
<tr class="memdesc:ad8cfa5e251b7a85343f0a92e93f50a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (load) for std::bitset.  <br /></td></tr>
<tr class="separator:ad8cfa5e251b7a85343f0a92e93f50a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef0d6cf11362910537f60cf2d977bff" id="r_aaef0d6cf11362910537f60cf2d977bff"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename ... VariantTypes&gt; </td></tr>
<tr class="memitem:aaef0d6cf11362910537f60cf2d977bff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaef0d6cf11362910537f60cf2d977bff">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, boost::variant&lt; VariantTypes... &gt; const &amp;variant)</td></tr>
<tr class="memdesc:aaef0d6cf11362910537f60cf2d977bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for boost::variant.  <br /></td></tr>
<tr class="separator:aaef0d6cf11362910537f60cf2d977bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890ad33a3d0ec4f9d7408e6e7e25e772" id="r_a890ad33a3d0ec4f9d7408e6e7e25e772"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename ... VariantTypes&gt; </td></tr>
<tr class="memitem:a890ad33a3d0ec4f9d7408e6e7e25e772"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a890ad33a3d0ec4f9d7408e6e7e25e772">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, boost::variant&lt; VariantTypes... &gt; &amp;variant)</td></tr>
<tr class="memdesc:a890ad33a3d0ec4f9d7408e6e7e25e772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for boost::variant.  <br /></td></tr>
<tr class="separator:a890ad33a3d0ec4f9d7408e6e7e25e772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873e6efe3a391c89edbee86fb2a4b349" id="r_a873e6efe3a391c89edbee86fb2a4b349"><td class="memTemplParams" colspan="2">template&lt;class Archive , class R , class P &gt; </td></tr>
<tr class="memitem:a873e6efe3a391c89edbee86fb2a4b349"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a873e6efe3a391c89edbee86fb2a4b349">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::chrono::duration&lt; R, P &gt; const &amp;dur)</td></tr>
<tr class="memdesc:a873e6efe3a391c89edbee86fb2a4b349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::chrono::duration.  <br /></td></tr>
<tr class="separator:a873e6efe3a391c89edbee86fb2a4b349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c5a2d538bb7606e5500f5e3a107e30" id="r_a09c5a2d538bb7606e5500f5e3a107e30"><td class="memTemplParams" colspan="2">template&lt;class Archive , class R , class P &gt; </td></tr>
<tr class="memitem:a09c5a2d538bb7606e5500f5e3a107e30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09c5a2d538bb7606e5500f5e3a107e30">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::chrono::duration&lt; R, P &gt; &amp;dur)</td></tr>
<tr class="memdesc:a09c5a2d538bb7606e5500f5e3a107e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::chrono::duration.  <br /></td></tr>
<tr class="separator:a09c5a2d538bb7606e5500f5e3a107e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977c1527242726fecf6cb1f492683ca6" id="r_a977c1527242726fecf6cb1f492683ca6"><td class="memTemplParams" colspan="2">template&lt;class Archive , class C , class D &gt; </td></tr>
<tr class="memitem:a977c1527242726fecf6cb1f492683ca6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a977c1527242726fecf6cb1f492683ca6">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::chrono::time_point&lt; C, D &gt; const &amp;dur)</td></tr>
<tr class="memdesc:a977c1527242726fecf6cb1f492683ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::chrono::time_point.  <br /></td></tr>
<tr class="separator:a977c1527242726fecf6cb1f492683ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b65d3b13a15b4f35c1b21553ab7649" id="r_ab8b65d3b13a15b4f35c1b21553ab7649"><td class="memTemplParams" colspan="2">template&lt;class Archive , class C , class D &gt; </td></tr>
<tr class="memitem:ab8b65d3b13a15b4f35c1b21553ab7649"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8b65d3b13a15b4f35c1b21553ab7649">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::chrono::time_point&lt; C, D &gt; &amp;dur)</td></tr>
<tr class="memdesc:ab8b65d3b13a15b4f35c1b21553ab7649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::chrono::time_point.  <br /></td></tr>
<tr class="separator:ab8b65d3b13a15b4f35c1b21553ab7649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa282de424af3d15ebfd094a216029149" id="r_aa282de424af3d15ebfd094a216029149"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aa282de424af3d15ebfd094a216029149"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, typenamecommon_detail::is_enum&lt; T &gt;::base_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa282de424af3d15ebfd094a216029149">CEREAL_SAVE_MINIMAL_FUNCTION_NAME</a> (Archive const &amp;, T const &amp;t)</td></tr>
<tr class="memdesc:aa282de424af3d15ebfd094a216029149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for enum types.  <br /></td></tr>
<tr class="separator:aa282de424af3d15ebfd094a216029149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4c34802b85e6ef9331374de8be9d22" id="r_a0a4c34802b85e6ef9331374de8be9d22"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a0a4c34802b85e6ef9331374de8be9d22"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0a4c34802b85e6ef9331374de8be9d22">CEREAL_LOAD_MINIMAL_FUNCTION_NAME</a> (Archive const &amp;, T &amp;&amp;t, typename <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;::base_type const &amp;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">value</a>)</td></tr>
<tr class="memdesc:a0a4c34802b85e6ef9331374de8be9d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for enum types.  <br /></td></tr>
<tr class="separator:a0a4c34802b85e6ef9331374de8be9d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676a85ac8cfcd512a743f930a10b6770" id="r_a676a85ac8cfcd512a743f930a10b6770"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a676a85ac8cfcd512a743f930a10b6770"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a676a85ac8cfcd512a743f930a10b6770">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;, T *&amp;)</td></tr>
<tr class="memdesc:a676a85ac8cfcd512a743f930a10b6770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for raw pointers.  <br /></td></tr>
<tr class="separator:a676a85ac8cfcd512a743f930a10b6770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03728f69af179b3cb5e2ec9131b8ccc3" id="r_a03728f69af179b3cb5e2ec9131b8ccc3"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a03728f69af179b3cb5e2ec9131b8ccc3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_array&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a03728f69af179b3cb5e2ec9131b8ccc3">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, T &amp;array)</td></tr>
<tr class="memdesc:a03728f69af179b3cb5e2ec9131b8ccc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for C style arrays.  <br /></td></tr>
<tr class="separator:a03728f69af179b3cb5e2ec9131b8ccc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548257a795f8540c86333d0758fb99d5" id="r_a548257a795f8540c86333d0758fb99d5"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a548257a795f8540c86333d0758fb99d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a548257a795f8540c86333d0758fb99d5">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::complex&lt; T &gt; const &amp;comp)</td></tr>
<tr class="memdesc:a548257a795f8540c86333d0758fb99d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (save) for std::complex.  <br /></td></tr>
<tr class="separator:a548257a795f8540c86333d0758fb99d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc7cefa0f45ae9d873598fdc607320e" id="r_afdc7cefa0f45ae9d873598fdc607320e"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:afdc7cefa0f45ae9d873598fdc607320e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afdc7cefa0f45ae9d873598fdc607320e">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::complex&lt; T &gt; &amp;bits)</td></tr>
<tr class="memdesc:afdc7cefa0f45ae9d873598fdc607320e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing (load) for std::complex.  <br /></td></tr>
<tr class="separator:afdc7cefa0f45ae9d873598fdc607320e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5992e59041b20f902dd4fa0b2c62f1" id="r_a0c5992e59041b20f902dd4fa0b2c62f1"><td class="memTemplParams" colspan="2">template&lt;class Archive , template&lt; typename... &gt; class Map, typename... Args, typename  = typename Map&lt;Args...&gt;::mapped_type&gt; </td></tr>
<tr class="memitem:a0c5992e59041b20f902dd4fa0b2c62f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0c5992e59041b20f902dd4fa0b2c62f1">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, Map&lt; Args... &gt; const &amp;map)</td></tr>
<tr class="memdesc:a0c5992e59041b20f902dd4fa0b2c62f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std-like pair associative containers.  <br /></td></tr>
<tr class="separator:a0c5992e59041b20f902dd4fa0b2c62f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679144f687ff95c7111ff96bccc573b3" id="r_a679144f687ff95c7111ff96bccc573b3"><td class="memTemplParams" colspan="2">template&lt;class Archive , template&lt; typename... &gt; class Map, typename... Args, typename  = typename Map&lt;Args...&gt;::mapped_type&gt; </td></tr>
<tr class="memitem:a679144f687ff95c7111ff96bccc573b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a679144f687ff95c7111ff96bccc573b3">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, Map&lt; Args... &gt; &amp;map)</td></tr>
<tr class="memdesc:a679144f687ff95c7111ff96bccc573b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std-like pair associative containers.  <br /></td></tr>
<tr class="separator:a679144f687ff95c7111ff96bccc573b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7e7370c46e4a819bd35fc1cdb856ad" id="r_a2e7e7370c46e4a819bd35fc1cdb856ad"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a2e7e7370c46e4a819bd35fc1cdb856ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e7e7370c46e4a819bd35fc1cdb856ad">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::deque&lt; T, A &gt; const &amp;deque)</td></tr>
<tr class="memdesc:a2e7e7370c46e4a819bd35fc1cdb856ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::deque.  <br /></td></tr>
<tr class="separator:a2e7e7370c46e4a819bd35fc1cdb856ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284b8541ec2e00a17dada43f2d59d878" id="r_a284b8541ec2e00a17dada43f2d59d878"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a284b8541ec2e00a17dada43f2d59d878"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a284b8541ec2e00a17dada43f2d59d878">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::deque&lt; T, A &gt; &amp;deque)</td></tr>
<tr class="memdesc:a284b8541ec2e00a17dada43f2d59d878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::deque.  <br /></td></tr>
<tr class="separator:a284b8541ec2e00a17dada43f2d59d878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69af5df93ccfbbb3cc02575e3aeadbc6" id="r_a69af5df93ccfbbb3cc02575e3aeadbc6"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a69af5df93ccfbbb3cc02575e3aeadbc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a69af5df93ccfbbb3cc02575e3aeadbc6">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::forward_list&lt; T, A &gt; const &amp;forward_list)</td></tr>
<tr class="memdesc:a69af5df93ccfbbb3cc02575e3aeadbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::forward_list all other types.  <br /></td></tr>
<tr class="separator:a69af5df93ccfbbb3cc02575e3aeadbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e9e22a3423e77493cee1d858372579" id="r_a42e9e22a3423e77493cee1d858372579"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a42e9e22a3423e77493cee1d858372579"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a42e9e22a3423e77493cee1d858372579">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::forward_list&lt; T, A &gt; &amp;forward_list)</td></tr>
<tr class="memdesc:a42e9e22a3423e77493cee1d858372579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::forward_list all other types from.  <br /></td></tr>
<tr class="separator:a42e9e22a3423e77493cee1d858372579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f9cfc9a4055c8a49eb050b02cd3357" id="r_a02f9cfc9a4055c8a49eb050b02cd3357"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a02f9cfc9a4055c8a49eb050b02cd3357"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a02f9cfc9a4055c8a49eb050b02cd3357">serialize</a> (Archive &amp;, std::less&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:a02f9cfc9a4055c8a49eb050b02cd3357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::less.  <br /></td></tr>
<tr class="separator:a02f9cfc9a4055c8a49eb050b02cd3357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5738ab4196d02509a5b69a58c7ca6ba" id="r_ad5738ab4196d02509a5b69a58c7ca6ba"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:ad5738ab4196d02509a5b69a58c7ca6ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad5738ab4196d02509a5b69a58c7ca6ba">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::list&lt; T, A &gt; const &amp;list)</td></tr>
<tr class="memdesc:ad5738ab4196d02509a5b69a58c7ca6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::list.  <br /></td></tr>
<tr class="separator:ad5738ab4196d02509a5b69a58c7ca6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55808d42ce0c468d57c34bbc07827e59" id="r_a55808d42ce0c468d57c34bbc07827e59"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a55808d42ce0c468d57c34bbc07827e59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a55808d42ce0c468d57c34bbc07827e59">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::list&lt; T, A &gt; &amp;list)</td></tr>
<tr class="memdesc:a55808d42ce0c468d57c34bbc07827e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::list.  <br /></td></tr>
<tr class="separator:a55808d42ce0c468d57c34bbc07827e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f598f6d4fbee3b354eb83e597cb0ebe" id="r_a8f598f6d4fbee3b354eb83e597cb0ebe"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a8f598f6d4fbee3b354eb83e597cb0ebe"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f598f6d4fbee3b354eb83e597cb0ebe">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a8f598f6d4fbee3b354eb83e597cb0ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for non polymorphic types.  <br /></td></tr>
<tr class="separator:a8f598f6d4fbee3b354eb83e597cb0ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada32ad49436ba6eadf59fe88c9ffc6d8" id="r_ada32ad49436ba6eadf59fe88c9ffc6d8"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ada32ad49436ba6eadf59fe88c9ffc6d8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ada32ad49436ba6eadf59fe88c9ffc6d8">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:ada32ad49436ba6eadf59fe88c9ffc6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr, case when no user load and construct for non polymorphic types.  <br /></td></tr>
<tr class="separator:ada32ad49436ba6eadf59fe88c9ffc6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac5820fd45ce7b235c753be49a2913c" id="r_a6ac5820fd45ce7b235c753be49a2913c"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a6ac5820fd45ce7b235c753be49a2913c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ac5820fd45ce7b235c753be49a2913c">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::weak_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a6ac5820fd45ce7b235c753be49a2913c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::weak_ptr for non polymorphic types.  <br /></td></tr>
<tr class="separator:a6ac5820fd45ce7b235c753be49a2913c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a9fc2e4a59628aca00743710cf238f" id="r_ad4a9fc2e4a59628aca00743710cf238f"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ad4a9fc2e4a59628aca00743710cf238f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad4a9fc2e4a59628aca00743710cf238f">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::weak_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:ad4a9fc2e4a59628aca00743710cf238f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::weak_ptr for non polymorphic types.  <br /></td></tr>
<tr class="separator:ad4a9fc2e4a59628aca00743710cf238f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84435d57b8944c536bb585c6516df09" id="r_ac84435d57b8944c536bb585c6516df09"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:ac84435d57b8944c536bb585c6516df09"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac84435d57b8944c536bb585c6516df09">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:ac84435d57b8944c536bb585c6516df09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for non polymorphic types.  <br /></td></tr>
<tr class="separator:ac84435d57b8944c536bb585c6516df09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97838af98c4fb9f5d42d928a1a4d64b5" id="r_a97838af98c4fb9f5d42d928a1a4d64b5"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a97838af98c4fb9f5d42d928a1a4d64b5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97838af98c4fb9f5d42d928a1a4d64b5">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a97838af98c4fb9f5d42d928a1a4d64b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when user provides load_and_construct for non polymorphic types.  <br /></td></tr>
<tr class="separator:a97838af98c4fb9f5d42d928a1a4d64b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dd1ac3ad73ad7203acdc21d7ea995a" id="r_ac2dd1ac3ad73ad7203acdc21d7ea995a"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ac2dd1ac3ad73ad7203acdc21d7ea995a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac2dd1ac3ad73ad7203acdc21d7ea995a">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; const &amp; &gt; const &amp;wrapper)</td></tr>
<tr class="memdesc:ac2dd1ac3ad73ad7203acdc21d7ea995a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr (wrapper implementation)  <br /></td></tr>
<tr class="separator:ac2dd1ac3ad73ad7203acdc21d7ea995a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b046d36c3921f4bf7230ace29d26cd1" id="r_a2b046d36c3921f4bf7230ace29d26cd1"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a2b046d36c3921f4bf7230ace29d26cd1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b046d36c3921f4bf7230ace29d26cd1">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:a2b046d36c3921f4bf7230ace29d26cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr, case when user load and construct (wrapper implementation)  <br /></td></tr>
<tr class="separator:a2b046d36c3921f4bf7230ace29d26cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6796fd8ee95e0bd42b4cafe09c46c7" id="r_aca6796fd8ee95e0bd42b4cafe09c46c7"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:aca6796fd8ee95e0bd42b4cafe09c46c7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca6796fd8ee95e0bd42b4cafe09c46c7">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:aca6796fd8ee95e0bd42b4cafe09c46c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr, case when no user load and construct (wrapper implementation)  <br /></td></tr>
<tr class="separator:aca6796fd8ee95e0bd42b4cafe09c46c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5576cf5fa2dc553adca652003d232d" id="r_a7a5576cf5fa2dc553adca652003d232d"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a7a5576cf5fa2dc553adca652003d232d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7a5576cf5fa2dc553adca652003d232d">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; const &amp; &gt; const &amp;wrapper)</td></tr>
<tr class="memdesc:a7a5576cf5fa2dc553adca652003d232d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr (wrapper implementation)  <br /></td></tr>
<tr class="separator:a7a5576cf5fa2dc553adca652003d232d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae566380527639f7e35ec9144dff7350e" id="r_ae566380527639f7e35ec9144dff7350e"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:ae566380527639f7e35ec9144dff7350e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae566380527639f7e35ec9144dff7350e">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:ae566380527639f7e35ec9144dff7350e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when user provides load_and_construct (wrapper implementation)  <br /></td></tr>
<tr class="separator:ae566380527639f7e35ec9144dff7350e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6b7247746d82f9ae810047390e8e61" id="r_a9e6b7247746d82f9ae810047390e8e61"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a9e6b7247746d82f9ae810047390e8e61"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e6b7247746d82f9ae810047390e8e61">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, <a class="el" href="structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; &amp; &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:a9e6b7247746d82f9ae810047390e8e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when no load_and_construct (wrapper implementation)  <br /></td></tr>
<tr class="separator:a9e6b7247746d82f9ae810047390e8e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede65f937d9a4d9ebaef35db8c6e7ae7" id="r_aede65f937d9a4d9ebaef35db8c6e7ae7"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename T &gt; </td></tr>
<tr class="memitem:aede65f937d9a4d9ebaef35db8c6e7ae7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aede65f937d9a4d9ebaef35db8c6e7ae7">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, const std::optional&lt; T &gt; &amp;optional)</td></tr>
<tr class="memdesc:aede65f937d9a4d9ebaef35db8c6e7ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::optional.  <br /></td></tr>
<tr class="separator:aede65f937d9a4d9ebaef35db8c6e7ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be4f81090e80f115a2ac4041a9f16ca" id="r_a8be4f81090e80f115a2ac4041a9f16ca"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename T &gt; </td></tr>
<tr class="memitem:a8be4f81090e80f115a2ac4041a9f16ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8be4f81090e80f115a2ac4041a9f16ca">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::optional&lt; T &gt; &amp;optional)</td></tr>
<tr class="memdesc:a8be4f81090e80f115a2ac4041a9f16ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::optional.  <br /></td></tr>
<tr class="separator:a8be4f81090e80f115a2ac4041a9f16ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad178feaa536101818dbed91f516d7a3d" id="r_ad178feaa536101818dbed91f516d7a3d"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ad178feaa536101818dbed91f516d7a3d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_abstract&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad178feaa536101818dbed91f516d7a3d">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:ad178feaa536101818dbed91f516d7a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for polymorphic types, abstract.  <br /></td></tr>
<tr class="separator:ad178feaa536101818dbed91f516d7a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d7ca1d179cff040e96656467c821c8" id="r_ad6d7ca1d179cff040e96656467c821c8"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:ad6d7ca1d179cff040e96656467c821c8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;!std::is_abstract&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad6d7ca1d179cff040e96656467c821c8">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:ad6d7ca1d179cff040e96656467c821c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::shared_ptr for polymorphic types, not abstract.  <br /></td></tr>
<tr class="separator:ad6d7ca1d179cff040e96656467c821c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4daf2a3346e5b8f0b63685084ac017" id="r_a2e4daf2a3346e5b8f0b63685084ac017"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a2e4daf2a3346e5b8f0b63685084ac017"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2e4daf2a3346e5b8f0b63685084ac017">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::shared_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a2e4daf2a3346e5b8f0b63685084ac017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::shared_ptr for polymorphic types.  <br /></td></tr>
<tr class="separator:a2e4daf2a3346e5b8f0b63685084ac017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abec1a5b79a96fac6e8a9452d6d5efc" id="r_a6abec1a5b79a96fac6e8a9452d6d5efc"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a6abec1a5b79a96fac6e8a9452d6d5efc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6abec1a5b79a96fac6e8a9452d6d5efc">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::weak_ptr&lt; T &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a6abec1a5b79a96fac6e8a9452d6d5efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::weak_ptr for polymorphic types.  <br /></td></tr>
<tr class="separator:a6abec1a5b79a96fac6e8a9452d6d5efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc67713d049bdcac7a754c1f481641cf" id="r_adc67713d049bdcac7a754c1f481641cf"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:adc67713d049bdcac7a754c1f481641cf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc67713d049bdcac7a754c1f481641cf">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::weak_ptr&lt; T &gt; &amp;ptr)</td></tr>
<tr class="memdesc:adc67713d049bdcac7a754c1f481641cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::weak_ptr for polymorphic types.  <br /></td></tr>
<tr class="separator:adc67713d049bdcac7a754c1f481641cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bf933f694e73578a268e7566c01443" id="r_a65bf933f694e73578a268e7566c01443"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a65bf933f694e73578a268e7566c01443"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_abstract&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a65bf933f694e73578a268e7566c01443">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a65bf933f694e73578a268e7566c01443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for polymorphic types that are abstract.  <br /></td></tr>
<tr class="separator:a65bf933f694e73578a268e7566c01443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e704d8ad2170ff91ad710ed776d0727" id="r_a9e704d8ad2170ff91ad710ed776d0727"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a9e704d8ad2170ff91ad710ed776d0727"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;!std::is_abstract&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e704d8ad2170ff91ad710ed776d0727">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; const &amp;ptr)</td></tr>
<tr class="memdesc:a9e704d8ad2170ff91ad710ed776d0727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving std::unique_ptr for polymorphic types, not abstract.  <br /></td></tr>
<tr class="separator:a9e704d8ad2170ff91ad710ed776d0727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec1b39135bb383c96bf8a072bfea397" id="r_a0ec1b39135bb383c96bf8a072bfea397"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class D &gt; </td></tr>
<tr class="memitem:a0ec1b39135bb383c96bf8a072bfea397"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ec1b39135bb383c96bf8a072bfea397">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::unique_ptr&lt; T, D &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a0ec1b39135bb383c96bf8a072bfea397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading std::unique_ptr, case when user provides load_and_construct for polymorphic types.  <br /></td></tr>
<tr class="separator:a0ec1b39135bb383c96bf8a072bfea397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196f5ec0e6eb126730ee5fb7339fb8be" id="r_a196f5ec0e6eb126730ee5fb7339fb8be"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class C &gt; </td></tr>
<tr class="memitem:a196f5ec0e6eb126730ee5fb7339fb8be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a196f5ec0e6eb126730ee5fb7339fb8be">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::queue&lt; T, C &gt; const &amp;queue)</td></tr>
<tr class="memdesc:a196f5ec0e6eb126730ee5fb7339fb8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::queue.  <br /></td></tr>
<tr class="separator:a196f5ec0e6eb126730ee5fb7339fb8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663f35fc093d002d4e07c0e965178525" id="r_a663f35fc093d002d4e07c0e965178525"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class C &gt; </td></tr>
<tr class="memitem:a663f35fc093d002d4e07c0e965178525"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a663f35fc093d002d4e07c0e965178525">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::queue&lt; T, C &gt; &amp;queue)</td></tr>
<tr class="memdesc:a663f35fc093d002d4e07c0e965178525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::queue.  <br /></td></tr>
<tr class="separator:a663f35fc093d002d4e07c0e965178525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1957ae53b8fc963c0ed3e831deae7ca" id="r_ad1957ae53b8fc963c0ed3e831deae7ca"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class C , class Comp &gt; </td></tr>
<tr class="memitem:ad1957ae53b8fc963c0ed3e831deae7ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad1957ae53b8fc963c0ed3e831deae7ca">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::priority_queue&lt; T, C, Comp &gt; const &amp;priority_queue)</td></tr>
<tr class="memdesc:ad1957ae53b8fc963c0ed3e831deae7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::priority_queue.  <br /></td></tr>
<tr class="separator:ad1957ae53b8fc963c0ed3e831deae7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9335c1a68710bfa8f49ae3a217b32623" id="r_a9335c1a68710bfa8f49ae3a217b32623"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class C , class Comp &gt; </td></tr>
<tr class="memitem:a9335c1a68710bfa8f49ae3a217b32623"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9335c1a68710bfa8f49ae3a217b32623">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::priority_queue&lt; T, C, Comp &gt; &amp;priority_queue)</td></tr>
<tr class="memdesc:a9335c1a68710bfa8f49ae3a217b32623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::priority_queue.  <br /></td></tr>
<tr class="separator:a9335c1a68710bfa8f49ae3a217b32623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a8cea063806602d60157cf1fb90878" id="r_a76a8cea063806602d60157cf1fb90878"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class C , class A &gt; </td></tr>
<tr class="memitem:a76a8cea063806602d60157cf1fb90878"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a76a8cea063806602d60157cf1fb90878">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::set&lt; K, C, A &gt; const &amp;set)</td></tr>
<tr class="memdesc:a76a8cea063806602d60157cf1fb90878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::set.  <br /></td></tr>
<tr class="separator:a76a8cea063806602d60157cf1fb90878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a65f7506d96c59b25e5ad4bb6d6ad5" id="r_a79a65f7506d96c59b25e5ad4bb6d6ad5"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class C , class A &gt; </td></tr>
<tr class="memitem:a79a65f7506d96c59b25e5ad4bb6d6ad5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a79a65f7506d96c59b25e5ad4bb6d6ad5">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::set&lt; K, C, A &gt; &amp;set)</td></tr>
<tr class="memdesc:a79a65f7506d96c59b25e5ad4bb6d6ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::set.  <br /></td></tr>
<tr class="separator:a79a65f7506d96c59b25e5ad4bb6d6ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7424502dce9a6a12bc8b0c34c8fa04" id="r_aba7424502dce9a6a12bc8b0c34c8fa04"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class C , class A &gt; </td></tr>
<tr class="memitem:aba7424502dce9a6a12bc8b0c34c8fa04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba7424502dce9a6a12bc8b0c34c8fa04">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::multiset&lt; K, C, A &gt; const &amp;multiset)</td></tr>
<tr class="memdesc:aba7424502dce9a6a12bc8b0c34c8fa04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::multiset.  <br /></td></tr>
<tr class="separator:aba7424502dce9a6a12bc8b0c34c8fa04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6668a1fc6b49fcf9c53633e3eb385826" id="r_a6668a1fc6b49fcf9c53633e3eb385826"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class C , class A &gt; </td></tr>
<tr class="memitem:a6668a1fc6b49fcf9c53633e3eb385826"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6668a1fc6b49fcf9c53633e3eb385826">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::multiset&lt; K, C, A &gt; &amp;multiset)</td></tr>
<tr class="memdesc:a6668a1fc6b49fcf9c53633e3eb385826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::multiset.  <br /></td></tr>
<tr class="separator:a6668a1fc6b49fcf9c53633e3eb385826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1f0d917ab00dd67f0b0e7d71737628" id="r_aca1f0d917ab00dd67f0b0e7d71737628"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class C &gt; </td></tr>
<tr class="memitem:aca1f0d917ab00dd67f0b0e7d71737628"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aca1f0d917ab00dd67f0b0e7d71737628">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::stack&lt; T, C &gt; const &amp;stack)</td></tr>
<tr class="memdesc:aca1f0d917ab00dd67f0b0e7d71737628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::stack.  <br /></td></tr>
<tr class="separator:aca1f0d917ab00dd67f0b0e7d71737628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f082383d87633cf69bdf0ab3d450ad" id="r_af7f082383d87633cf69bdf0ab3d450ad"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class C &gt; </td></tr>
<tr class="memitem:af7f082383d87633cf69bdf0ab3d450ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af7f082383d87633cf69bdf0ab3d450ad">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::stack&lt; T, C &gt; &amp;stack)</td></tr>
<tr class="memdesc:af7f082383d87633cf69bdf0ab3d450ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::stack.  <br /></td></tr>
<tr class="separator:af7f082383d87633cf69bdf0ab3d450ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8e2f5032a22f0576cb08567f2d8e6f" id="r_a6c8e2f5032a22f0576cb08567f2d8e6f"><td class="memTemplParams" colspan="2">template&lt;class Archive , class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a6c8e2f5032a22f0576cb08567f2d8e6f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; CharT &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c8e2f5032a22f0576cb08567f2d8e6f">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;str)</td></tr>
<tr class="memdesc:a6c8e2f5032a22f0576cb08567f2d8e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for basic_string types, if binary data is supported.  <br /></td></tr>
<tr class="separator:a6c8e2f5032a22f0576cb08567f2d8e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5719e2d913b81926159a1962ec95547" id="r_ac5719e2d913b81926159a1962ec95547"><td class="memTemplParams" colspan="2">template&lt;class Archive , class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:ac5719e2d913b81926159a1962ec95547"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; CharT &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac5719e2d913b81926159a1962ec95547">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;str)</td></tr>
<tr class="memdesc:ac5719e2d913b81926159a1962ec95547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for basic_string types, if binary data is supported.  <br /></td></tr>
<tr class="separator:ac5719e2d913b81926159a1962ec95547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660edef0c6b018675e109062d459dc82" id="r_a660edef0c6b018675e109062d459dc82"><td class="memTemplParams" colspan="2">template&lt;class Archive , class ... Types&gt; </td></tr>
<tr class="memitem:a660edef0c6b018675e109062d459dc82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a660edef0c6b018675e109062d459dc82">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, std::tuple&lt; Types... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:a660edef0c6b018675e109062d459dc82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing for std::tuple.  <br /></td></tr>
<tr class="separator:a660edef0c6b018675e109062d459dc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220a6067b52ed669c0c151d76567b561" id="r_a220a6067b52ed669c0c151d76567b561"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class H , class KE , class A &gt; </td></tr>
<tr class="memitem:a220a6067b52ed669c0c151d76567b561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a220a6067b52ed669c0c151d76567b561">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unordered_set&lt; K, H, KE, A &gt; const &amp;unordered_set)</td></tr>
<tr class="memdesc:a220a6067b52ed669c0c151d76567b561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::unordered_set.  <br /></td></tr>
<tr class="separator:a220a6067b52ed669c0c151d76567b561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b6234fc5a858bd294a833ccc9045ba" id="r_af0b6234fc5a858bd294a833ccc9045ba"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class H , class KE , class A &gt; </td></tr>
<tr class="memitem:af0b6234fc5a858bd294a833ccc9045ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af0b6234fc5a858bd294a833ccc9045ba">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::unordered_set&lt; K, H, KE, A &gt; &amp;unordered_set)</td></tr>
<tr class="memdesc:af0b6234fc5a858bd294a833ccc9045ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::unordered_set.  <br /></td></tr>
<tr class="separator:af0b6234fc5a858bd294a833ccc9045ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4385e91ff798d9c5f8c336470011b889" id="r_a4385e91ff798d9c5f8c336470011b889"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class H , class KE , class A &gt; </td></tr>
<tr class="memitem:a4385e91ff798d9c5f8c336470011b889"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4385e91ff798d9c5f8c336470011b889">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::unordered_multiset&lt; K, H, KE, A &gt; const &amp;unordered_multiset)</td></tr>
<tr class="memdesc:a4385e91ff798d9c5f8c336470011b889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::unordered_multiset.  <br /></td></tr>
<tr class="separator:a4385e91ff798d9c5f8c336470011b889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da956bad9ffcece46b8b3578a05567a" id="r_a7da956bad9ffcece46b8b3578a05567a"><td class="memTemplParams" colspan="2">template&lt;class Archive , class K , class H , class KE , class A &gt; </td></tr>
<tr class="memitem:a7da956bad9ffcece46b8b3578a05567a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7da956bad9ffcece46b8b3578a05567a">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::unordered_multiset&lt; K, H, KE, A &gt; &amp;unordered_multiset)</td></tr>
<tr class="memdesc:a7da956bad9ffcece46b8b3578a05567a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::unordered_multiset.  <br /></td></tr>
<tr class="separator:a7da956bad9ffcece46b8b3578a05567a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c80c9e74c022531318b7df731c1f73" id="r_a83c80c9e74c022531318b7df731c1f73"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a83c80c9e74c022531318b7df731c1f73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a83c80c9e74c022531318b7df731c1f73">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;ar, std::pair&lt; T1, T2 &gt; &amp;pair)</td></tr>
<tr class="memdesc:a83c80c9e74c022531318b7df731c1f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing for std::pair.  <br /></td></tr>
<tr class="separator:a83c80c9e74c022531318b7df731c1f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa97ef85d3c72b1bb9398c8c197fdd57" id="r_afa97ef85d3c72b1bb9398c8c197fdd57"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:afa97ef85d3c72b1bb9398c8c197fdd57"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afa97ef85d3c72b1bb9398c8c197fdd57">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::valarray&lt; T &gt; const &amp;valarray)</td></tr>
<tr class="memdesc:afa97ef85d3c72b1bb9398c8c197fdd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::valarray arithmetic types, using binary serialization, if supported.  <br /></td></tr>
<tr class="separator:afa97ef85d3c72b1bb9398c8c197fdd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcea0f4702c0571eaac2b23a6ad8125" id="r_a6dcea0f4702c0571eaac2b23a6ad8125"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a6dcea0f4702c0571eaac2b23a6ad8125"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6dcea0f4702c0571eaac2b23a6ad8125">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::valarray&lt; T &gt; &amp;valarray)</td></tr>
<tr class="memdesc:a6dcea0f4702c0571eaac2b23a6ad8125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::valarray arithmetic types, using binary serialization, if supported.  <br /></td></tr>
<tr class="separator:a6dcea0f4702c0571eaac2b23a6ad8125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8433d3fefce97949c3b895a50f9a8beb" id="r_a8433d3fefce97949c3b895a50f9a8beb"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a8433d3fefce97949c3b895a50f9a8beb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8433d3fefce97949c3b895a50f9a8beb">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::valarray&lt; T &gt; const &amp;valarray)</td></tr>
<tr class="memdesc:a8433d3fefce97949c3b895a50f9a8beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::valarray all other types.  <br /></td></tr>
<tr class="separator:a8433d3fefce97949c3b895a50f9a8beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b267f3c5857801c689781da4a74b5e" id="r_a40b267f3c5857801c689781da4a74b5e"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T &gt; </td></tr>
<tr class="memitem:a40b267f3c5857801c689781da4a74b5e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a40b267f3c5857801c689781da4a74b5e">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::valarray&lt; T &gt; &amp;valarray)</td></tr>
<tr class="memdesc:a40b267f3c5857801c689781da4a74b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::valarray all other types.  <br /></td></tr>
<tr class="separator:a40b267f3c5857801c689781da4a74b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216f04eb0fd673671c399e76270d7f5c" id="r_a216f04eb0fd673671c399e76270d7f5c"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename VariantType1 , typename... VariantTypes&gt; </td></tr>
<tr class="memitem:a216f04eb0fd673671c399e76270d7f5c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a216f04eb0fd673671c399e76270d7f5c">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::variant&lt; VariantType1, VariantTypes... &gt; const &amp;variant)</td></tr>
<tr class="memdesc:a216f04eb0fd673671c399e76270d7f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saving for std::variant.  <br /></td></tr>
<tr class="separator:a216f04eb0fd673671c399e76270d7f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d7a06a029441ecec4314f9fa64813e" id="r_ac7d7a06a029441ecec4314f9fa64813e"><td class="memTemplParams" colspan="2">template&lt;class Archive , typename... VariantTypes&gt; </td></tr>
<tr class="memitem:ac7d7a06a029441ecec4314f9fa64813e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac7d7a06a029441ecec4314f9fa64813e">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::variant&lt; VariantTypes... &gt; &amp;variant)</td></tr>
<tr class="memdesc:ac7d7a06a029441ecec4314f9fa64813e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loading for std::variant.  <br /></td></tr>
<tr class="separator:ac7d7a06a029441ecec4314f9fa64813e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e33aa2fc1bde7f59e9796f922cee3b9" id="r_a0e33aa2fc1bde7f59e9796f922cee3b9"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a0e33aa2fc1bde7f59e9796f922cee3b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0e33aa2fc1bde7f59e9796f922cee3b9">CEREAL_SERIALIZE_FUNCTION_NAME</a> (Archive &amp;, std::monostate const &amp;)</td></tr>
<tr class="memdesc:a0e33aa2fc1bde7f59e9796f922cee3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializing a std::monostate.  <br /></td></tr>
<tr class="separator:a0e33aa2fc1bde7f59e9796f922cee3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb789479aa9deae7b63d249f6dccccaf" id="r_adb789479aa9deae7b63d249f6dccccaf"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:adb789479aa9deae7b63d249f6dccccaf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;!std::is_same&lt; T, bool &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb789479aa9deae7b63d249f6dccccaf">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; T, A &gt; const &amp;vector)</td></tr>
<tr class="memdesc:adb789479aa9deae7b63d249f6dccccaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for std::vectors of arithmetic (but not bool) using binary serialization, if supported.  <br /></td></tr>
<tr class="separator:adb789479aa9deae7b63d249f6dccccaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8c0283f25c71df86060789614c4cfe" id="r_a3a8c0283f25c71df86060789614c4cfe"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a3a8c0283f25c71df86060789614c4cfe"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;!std::is_same&lt; T, bool &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3a8c0283f25c71df86060789614c4cfe">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; T, A &gt; &amp;vector)</td></tr>
<tr class="memdesc:a3a8c0283f25c71df86060789614c4cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for std::vectors of arithmetic (but not bool) using binary serialization, if supported.  <br /></td></tr>
<tr class="separator:a3a8c0283f25c71df86060789614c4cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae26efa958e82169d5f813bda0ad1c5" id="r_a4ae26efa958e82169d5f813bda0ad1c5"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a4ae26efa958e82169d5f813bda0ad1c5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>)&amp;&amp;!std::is_same&lt; T, bool &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4ae26efa958e82169d5f813bda0ad1c5">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; T, A &gt; const &amp;vector)</td></tr>
<tr class="memdesc:a4ae26efa958e82169d5f813bda0ad1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for non-arithmetic vector types.  <br /></td></tr>
<tr class="separator:a4ae26efa958e82169d5f813bda0ad1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa0955bf32e5651828e110004b6dc5d" id="r_a0aa0955bf32e5651828e110004b6dc5d"><td class="memTemplParams" colspan="2">template&lt;class Archive , class T , class A &gt; </td></tr>
<tr class="memitem:a0aa0955bf32e5651828e110004b6dc5d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>)&amp;&amp;!std::is_same&lt; T, bool &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0aa0955bf32e5651828e110004b6dc5d">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; T, A &gt; &amp;vector)</td></tr>
<tr class="memdesc:a0aa0955bf32e5651828e110004b6dc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for non-arithmetic vector types.  <br /></td></tr>
<tr class="separator:a0aa0955bf32e5651828e110004b6dc5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b613c5fc7ae5ec8f8216a6337955a7" id="r_a76b613c5fc7ae5ec8f8216a6337955a7"><td class="memTemplParams" colspan="2">template&lt;class Archive , class A &gt; </td></tr>
<tr class="memitem:a76b613c5fc7ae5ec8f8216a6337955a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a76b613c5fc7ae5ec8f8216a6337955a7">CEREAL_SAVE_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; bool, A &gt; const &amp;vector)</td></tr>
<tr class="memdesc:a76b613c5fc7ae5ec8f8216a6337955a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for bool vector types.  <br /></td></tr>
<tr class="separator:a76b613c5fc7ae5ec8f8216a6337955a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c7d1d922569ba782c8ec6d8f79b3e8" id="r_a09c7d1d922569ba782c8ec6d8f79b3e8"><td class="memTemplParams" colspan="2">template&lt;class Archive , class A &gt; </td></tr>
<tr class="memitem:a09c7d1d922569ba782c8ec6d8f79b3e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a09c7d1d922569ba782c8ec6d8f79b3e8">CEREAL_LOAD_FUNCTION_NAME</a> (Archive &amp;ar, std::vector&lt; bool, A &gt; &amp;vector)</td></tr>
<tr class="memdesc:a09c7d1d922569ba782c8ec6d8f79b3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization for bool vector types.  <br /></td></tr>
<tr class="separator:a09c7d1d922569ba782c8ec6d8f79b3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>in certain simple scenarios. They should probably not be used if maximizing performance is the main objective. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a0e01d80aaafe0efb12b75abdee310ae4" name="a0e01d80aaafe0efb12b75abdee310ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e01d80aaafe0efb12b75abdee310ae4">&#9670;&#160;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0e01d80aaafe0efb12b75abdee310ae4">cereal::size_type</a> = <a class="el" href="macros_8hpp.html#a2ad098b163a5f4829eb00fd7fb0b408d">CEREAL_SIZE_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size type used by cereal. </p>
<p>To ensure compatability between 32, 64, etc bit machines, we need to use a fixed size type instead of size_t, which may vary from machine to machine.</p>
<p>The default value for CEREAL_SIZE_TYPE is specified in <a class="el" href="macros_8hpp.html" title="Preprocessor macros that can customise the cereal library.">cereal/macros.hpp</a> </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a95185aa9f39e4ac382bb6631beb68a67" name="a95185aa9f39e4ac382bb6631beb68a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95185aa9f39e4ac382bb6631beb68a67">&#9670;&#160;</a></span>Flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a95185aa9f39e4ac382bb6631beb68a67">cereal::Flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special flags for archives. </p>
<p>AllowEmptyClassElision This allows for empty classes to be serialized even if they do not provide a serialization function. Classes with no data members are considered to be empty. Be warned that if this is enabled and you attempt to serialize an empty class with improperly formed serialize or load/save functions, no static error will occur - the error will propogate silently and your intended serialization functions may not be called. You can manually ensure that your classes that have custom serialization are correct by using the traits is_output_serializable and is_input_serializable in <a class="el" href="traits_8hpp.html" title="Internal type trait support.">cereal/details/traits.hpp</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a95185aa9f39e4ac382bb6631beb68a67ae264e38ef1170510fbdfa5f1e4d5c532" name="a95185aa9f39e4ac382bb6631beb68a67ae264e38ef1170510fbdfa5f1e4d5c532"></a>AllowEmptyClassElision&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ac28bb730353e53b3066cc679e63bb108" name="ac28bb730353e53b3066cc679e63bb108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28bb730353e53b3066cc679e63bb108">&#9670;&#160;</a></span>specialization</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , specialization S&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class specialization</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A specifier used in conjunction with <a class="el" href="structcereal_1_1specialize.html" title="A class used to disambiguate cases where cereal cannot detect a unique way of serializing a class.">cereal::specialize</a> to disambiguate serialization in special cases </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a890ad33a3d0ec4f9d7408e6e7e25e772" name="a890ad33a3d0ec4f9d7408e6e7e25e772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890ad33a3d0ec4f9d7408e6e7e25e772">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[1/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename ... VariantTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::variant&lt; VariantTypes... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>variant</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for boost::variant. </p>

</div>
</div>
<a id="a679144f687ff95c7111ff96bccc573b3" name="a679144f687ff95c7111ff96bccc573b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679144f687ff95c7111ff96bccc573b3">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[2/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , template&lt; typename... &gt; class Map, typename... Args, typename  = typename Map&lt;Args...&gt;::mapped_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map&lt; Args... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std-like pair associative containers. </p>

</div>
</div>
<a id="a2b046d36c3921f4bf7230ace29d26cd1" name="a2b046d36c3921f4bf7230ace29d26cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b046d36c3921f4bf7230ace29d26cd1">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[3/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>wrapper</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::shared_ptr, case when user load and construct (wrapper implementation) </p>

</div>
</div>
<a id="aca6796fd8ee95e0bd42b4cafe09c46c7" name="aca6796fd8ee95e0bd42b4cafe09c46c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6796fd8ee95e0bd42b4cafe09c46c7">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[4/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>wrapper</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::shared_ptr, case when no user load and construct (wrapper implementation) </p>

</div>
</div>
<a id="ae566380527639f7e35ec9144dff7350e" name="ae566380527639f7e35ec9144dff7350e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae566380527639f7e35ec9144dff7350e">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[5/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>wrapper</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::unique_ptr, case when user provides load_and_construct (wrapper implementation) </p>

</div>
</div>
<a id="a9e6b7247746d82f9ae810047390e8e61" name="a9e6b7247746d82f9ae810047390e8e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6b7247746d82f9ae810047390e8e61">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[6/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1has__load__and__construct.html">traits::has_load_and_construct</a>&lt; T, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; &amp; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>wrapper</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::unique_ptr, case when no load_and_construct (wrapper implementation) </p>

</div>
</div>
<a id="a5c962df81c2ad99813597b6238e3e17d" name="a5c962df81c2ad99813597b6238e3e17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c962df81c2ad99813597b6238e3e17d">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[7/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loading for std::array primitive types using binary serialization, if supported </p>

</div>
</div>
<a id="ad1956f9852b727abcb5ee439dd8abf39" name="ad1956f9852b727abcb5ee439dd8abf39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1956f9852b727abcb5ee439dd8abf39">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[8/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::array all other types. </p>

</div>
</div>
<a id="abfc0336db29043e0f692517c77f9e7de" name="abfc0336db29043e0f692517c77f9e7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc0336db29043e0f692517c77f9e7de">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[9/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::atomic&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing (load) for std::atomic. </p>

</div>
</div>
<a id="ac5719e2d913b81926159a1962ec95547" name="ac5719e2d913b81926159a1962ec95547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5719e2d913b81926159a1962ec95547">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[10/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; CharT &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for basic_string types, if binary data is supported. </p>

</div>
</div>
<a id="ad8cfa5e251b7a85343f0a92e93f50a60" name="ad8cfa5e251b7a85343f0a92e93f50a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8cfa5e251b7a85343f0a92e93f50a60">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[11/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::bitset&lt; N &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing (load) for std::bitset. </p>

</div>
</div>
<a id="a09c5a2d538bb7606e5500f5e3a107e30" name="a09c5a2d538bb7606e5500f5e3a107e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c5a2d538bb7606e5500f5e3a107e30">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[12/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class R , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; R, P &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dur</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::chrono::duration. </p>

</div>
</div>
<a id="ab8b65d3b13a15b4f35c1b21553ab7649" name="ab8b65d3b13a15b4f35c1b21553ab7649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b65d3b13a15b4f35c1b21553ab7649">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[13/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class C , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::time_point&lt; C, D &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>dur</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::chrono::time_point. </p>

</div>
</div>
<a id="afdc7cefa0f45ae9d873598fdc607320e" name="afdc7cefa0f45ae9d873598fdc607320e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc7cefa0f45ae9d873598fdc607320e">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[14/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing (load) for std::complex. </p>

</div>
</div>
<a id="a284b8541ec2e00a17dada43f2d59d878" name="a284b8541ec2e00a17dada43f2d59d878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284b8541ec2e00a17dada43f2d59d878">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[15/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; T, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>deque</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::deque. </p>

</div>
</div>
<a id="a42e9e22a3423e77493cee1d858372579" name="a42e9e22a3423e77493cee1d858372579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e9e22a3423e77493cee1d858372579">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[16/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; T, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>forward_list</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loading for std::forward_list all other types from. </p>

</div>
</div>
<a id="a55808d42ce0c468d57c34bbc07827e59" name="a55808d42ce0c468d57c34bbc07827e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55808d42ce0c468d57c34bbc07827e59">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[17/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; T, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::list. </p>

</div>
</div>
<a id="a6668a1fc6b49fcf9c53633e3eb385826" name="a6668a1fc6b49fcf9c53633e3eb385826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6668a1fc6b49fcf9c53633e3eb385826">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[18/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class C , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::multiset&lt; K, C, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>multiset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::multiset. </p>

</div>
</div>
<a id="a8be4f81090e80f115a2ac4041a9f16ca" name="a8be4f81090e80f115a2ac4041a9f16ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be4f81090e80f115a2ac4041a9f16ca">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[19/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>optional</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::optional. </p>

</div>
</div>
<a id="a9335c1a68710bfa8f49ae3a217b32623" name="a9335c1a68710bfa8f49ae3a217b32623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9335c1a68710bfa8f49ae3a217b32623">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[20/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class C , class Comp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::priority_queue&lt; T, C, Comp &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>priority_queue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::priority_queue. </p>

</div>
</div>
<a id="a663f35fc093d002d4e07c0e965178525" name="a663f35fc093d002d4e07c0e965178525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663f35fc093d002d4e07c0e965178525">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[21/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; T, C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>queue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::queue. </p>

</div>
</div>
<a id="a79a65f7506d96c59b25e5ad4bb6d6ad5" name="a79a65f7506d96c59b25e5ad4bb6d6ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a65f7506d96c59b25e5ad4bb6d6ad5">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[22/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class C , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; K, C, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::set. </p>

</div>
</div>
<a id="ada32ad49436ba6eadf59fe88c9ffc6d8" name="ada32ad49436ba6eadf59fe88c9ffc6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada32ad49436ba6eadf59fe88c9ffc6d8">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[23/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::shared_ptr, case when no user load and construct for non polymorphic types. </p>

</div>
</div>
<a id="a2e4daf2a3346e5b8f0b63685084ac017" name="a2e4daf2a3346e5b8f0b63685084ac017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4daf2a3346e5b8f0b63685084ac017">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[24/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::shared_ptr for polymorphic types. </p>

</div>
</div>
<a id="af7f082383d87633cf69bdf0ab3d450ad" name="af7f082383d87633cf69bdf0ab3d450ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f082383d87633cf69bdf0ab3d450ad">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[25/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; T, C &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>stack</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::stack. </p>

</div>
</div>
<a id="a97838af98c4fb9f5d42d928a1a4d64b5" name="a97838af98c4fb9f5d42d928a1a4d64b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97838af98c4fb9f5d42d928a1a4d64b5">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[26/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T, D &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::unique_ptr, case when user provides load_and_construct for non polymorphic types. </p>

</div>
</div>
<a id="a0ec1b39135bb383c96bf8a072bfea397" name="a0ec1b39135bb383c96bf8a072bfea397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec1b39135bb383c96bf8a072bfea397">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[27/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T, D &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::unique_ptr, case when user provides load_and_construct for polymorphic types. </p>

</div>
</div>
<a id="a7da956bad9ffcece46b8b3578a05567a" name="a7da956bad9ffcece46b8b3578a05567a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da956bad9ffcece46b8b3578a05567a">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[28/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class H , class KE , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_multiset&lt; K, H, KE, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>unordered_multiset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::unordered_multiset. </p>

</div>
</div>
<a id="af0b6234fc5a858bd294a833ccc9045ba" name="af0b6234fc5a858bd294a833ccc9045ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b6234fc5a858bd294a833ccc9045ba">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[29/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class H , class KE , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; K, H, KE, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>unordered_set</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::unordered_set. </p>

</div>
</div>
<a id="a6dcea0f4702c0571eaac2b23a6ad8125" name="a6dcea0f4702c0571eaac2b23a6ad8125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dcea0f4702c0571eaac2b23a6ad8125">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[30/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::valarray&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>valarray</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::valarray arithmetic types, using binary serialization, if supported. </p>

</div>
</div>
<a id="a40b267f3c5857801c689781da4a74b5e" name="a40b267f3c5857801c689781da4a74b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b267f3c5857801c689781da4a74b5e">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[31/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::valarray&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>valarray</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::valarray all other types. </p>

</div>
</div>
<a id="ac7d7a06a029441ecec4314f9fa64813e" name="ac7d7a06a029441ecec4314f9fa64813e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d7a06a029441ecec4314f9fa64813e">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[32/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename... VariantTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::variant&lt; VariantTypes... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>variant</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for std::variant. </p>

</div>
</div>
<a id="a09c7d1d922569ba782c8ec6d8f79b3e8" name="a09c7d1d922569ba782c8ec6d8f79b3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c7d1d922569ba782c8ec6d8f79b3e8">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[33/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for bool vector types. </p>

</div>
</div>
<a id="a3a8c0283f25c71df86060789614c4cfe" name="a3a8c0283f25c71df86060789614c4cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8c0283f25c71df86060789614c4cfe">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[34/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;!std::is_same&lt; T, bool &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for std::vectors of arithmetic (but not bool) using binary serialization, if supported. </p>

</div>
</div>
<a id="a0aa0955bf32e5651828e110004b6dc5d" name="a0aa0955bf32e5651828e110004b6dc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa0955bf32e5651828e110004b6dc5d">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[35/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(!<a class="el" href="structcereal_1_1traits_1_1is__input__serializable.html">traits::is_input_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>)&amp;&amp;!std::is_same&lt; T, bool &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for non-arithmetic vector types. </p>

</div>
</div>
<a id="ad4a9fc2e4a59628aca00743710cf238f" name="ad4a9fc2e4a59628aca00743710cf238f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a9fc2e4a59628aca00743710cf238f">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[36/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::weak_ptr&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::weak_ptr for non polymorphic types. </p>

</div>
</div>
<a id="adc67713d049bdcac7a754c1f481641cf" name="adc67713d049bdcac7a754c1f481641cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc67713d049bdcac7a754c1f481641cf">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[37/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::weak_ptr&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading std::weak_ptr for polymorphic types. </p>

</div>
</div>
<a id="af8577c2834d64922e9460cad77f9a3ac" name="af8577c2834d64922e9460cad77f9a3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8577c2834d64922e9460cad77f9a3ac">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[38/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_binary_input_archive.html">BinaryInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bd</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading binary data. </p>

</div>
</div>
<a id="a960b7971cfb99b3c826258369bfc01e9" name="a960b7971cfb99b3c826258369bfc01e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960b7971cfb99b3c826258369bfc01e9">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[39/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_binary_input_archive.html">BinaryInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for POD types from binary. </p>

</div>
</div>
<a id="a42319b92c41f6f15a86b69fcd87246d2" name="a42319b92c41f6f15a86b69fcd87246d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42319b92c41f6f15a86b69fcd87246d2">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[40/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8e7a02ebbdcca274a8c905878725057" name="ab8e7a02ebbdcca274a8c905878725057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e7a02ebbdcca274a8c905878725057">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[41/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>st</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading SizeTags from JSON. </p>

</div>
</div>
<a id="a8a9afcaeb51833d26e15a78d55e5ae30" name="a8a9afcaeb51833d26e15a78d55e5ae30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9afcaeb51833d26e15a78d55e5ae30">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[42/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>loading string from JSON </p>

</div>
</div>
<a id="aed7f1f974a532bbad87a7b4d8fe746e8" name="aed7f1f974a532bbad87a7b4d8fe746e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed7f1f974a532bbad87a7b4d8fe746e8">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[43/50]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading arithmetic from JSON. </p>

</div>
</div>
<a id="af0f34376d3320a6fd7be58df311bd961" name="af0f34376d3320a6fd7be58df311bd961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f34376d3320a6fd7be58df311bd961">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[44/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading arithmetic from JSON. </p>

</div>
</div>
<a id="a10780060393e472b72fb4a2158d641ec" name="a10780060393e472b72fb4a2158d641ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10780060393e472b72fb4a2158d641ec">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[45/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_portable_binary_input_archive.html">PortableBinaryInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bd</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading binary data from portable binary. </p>

</div>
</div>
<a id="a8969743ff3cd671810d314350f4d4a8a" name="a8969743ff3cd671810d314350f4d4a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8969743ff3cd671810d314350f4d4a8a">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[46/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_portable_binary_input_archive.html">PortableBinaryInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for POD types from portable binary. </p>

</div>
</div>
<a id="a0a08767af52642e109545f05a4694380" name="a0a08767af52642e109545f05a4694380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a08767af52642e109545f05a4694380">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[47/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading NVP types from XML. </p>

</div>
</div>
<a id="a88090838a4dbf54f907dee8969c0d5cf" name="a88090838a4dbf54f907dee8969c0d5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88090838a4dbf54f907dee8969c0d5cf">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[48/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>st</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading SizeTags from XML. </p>

</div>
</div>
<a id="a3f5b214a91e6d61bcdae422e1cf27b37" name="a3f5b214a91e6d61bcdae422e1cf27b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f5b214a91e6d61bcdae422e1cf27b37">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[49/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>loading string from xml </p>

</div>
</div>
<a id="aea476a67114d4998f2113da658c25468" name="aea476a67114d4998f2113da658c25468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea476a67114d4998f2113da658c25468">&#9670;&#160;</a></span>CEREAL_LOAD_FUNCTION_NAME() <span class="overload">[50/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_LOAD_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for POD types from xml. </p>

</div>
</div>
<a id="a0a4c34802b85e6ef9331374de8be9d22" name="a0a4c34802b85e6ef9331374de8be9d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a4c34802b85e6ef9331374de8be9d22">&#9670;&#160;</a></span>CEREAL_LOAD_MINIMAL_FUNCTION_NAME()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_LOAD_MINIMAL_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive const &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>t</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;::base_type const &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loading for enum types. </p>

</div>
</div>
<a id="aaef0d6cf11362910537f60cf2d977bff" name="aaef0d6cf11362910537f60cf2d977bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef0d6cf11362910537f60cf2d977bff">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[1/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename ... VariantTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::variant&lt; VariantTypes... &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>variant</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for boost::variant. </p>

</div>
</div>
<a id="aede65f937d9a4d9ebaef35db8c6e7ae7" name="aede65f937d9a4d9ebaef35db8c6e7ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede65f937d9a4d9ebaef35db8c6e7ae7">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[2/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>optional</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::optional. </p>

</div>
</div>
<a id="a0c5992e59041b20f902dd4fa0b2c62f1" name="a0c5992e59041b20f902dd4fa0b2c62f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5992e59041b20f902dd4fa0b2c62f1">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[3/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , template&lt; typename... &gt; class Map, typename... Args, typename  = typename Map&lt;Args...&gt;::mapped_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Map&lt; Args... &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std-like pair associative containers. </p>

</div>
</div>
<a id="ac2dd1ac3ad73ad7203acdc21d7ea995a" name="ac2dd1ac3ad73ad7203acdc21d7ea995a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2dd1ac3ad73ad7203acdc21d7ea995a">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[4/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::shared_ptr&lt; T &gt; const &amp; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>wrapper</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::shared_ptr (wrapper implementation) </p>

</div>
</div>
<a id="a7a5576cf5fa2dc553adca652003d232d" name="a7a5576cf5fa2dc553adca652003d232d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5576cf5fa2dc553adca652003d232d">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[5/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1memory__detail_1_1_ptr_wrapper.html">memory_detail::PtrWrapper</a>&lt; std::unique_ptr&lt; T, D &gt; const &amp; &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>wrapper</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::unique_ptr (wrapper implementation) </p>

</div>
</div>
<a id="a54c9c74df6d91319b01128690322690a" name="a54c9c74df6d91319b01128690322690a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c9c74df6d91319b01128690322690a">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[6/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saving for std::array primitive types using binary serialization, if supported </p>

</div>
</div>
<a id="a668c4c41f5ca325091d5a357f89040c3" name="a668c4c41f5ca325091d5a357f89040c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668c4c41f5ca325091d5a357f89040c3">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[7/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::array&lt; T, N &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::array all other types. </p>

</div>
</div>
<a id="a99bab555e921d35f6f713b7e1cab187a" name="a99bab555e921d35f6f713b7e1cab187a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bab555e921d35f6f713b7e1cab187a">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[8/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::atomic&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing (save) for std::atomic. </p>

</div>
</div>
<a id="a6c8e2f5032a22f0576cb08567f2d8e6f" name="a6c8e2f5032a22f0576cb08567f2d8e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8e2f5032a22f0576cb08567f2d8e6f">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[9/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; CharT &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for basic_string types, if binary data is supported. </p>

</div>
</div>
<a id="a397c996c1b3e8bdcb3f43f11edf91126" name="a397c996c1b3e8bdcb3f43f11edf91126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397c996c1b3e8bdcb3f43f11edf91126">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[10/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , size_t N, traits::EnableIf&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; std::uint32_t &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::bitset&lt; N &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>bits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing (save) for std::bitset when <a class="el" href="structcereal_1_1_binary_data.html" title="A wrapper around data that can be serialized in a binary fashion.">BinaryData</a> optimization supported. </p>
<p>Serializing (save) for std::bitset when <a class="el" href="structcereal_1_1_binary_data.html" title="A wrapper around data that can be serialized in a binary fashion.">BinaryData</a> is not supported. </p>

</div>
</div>
<a id="a873e6efe3a391c89edbee86fb2a4b349" name="a873e6efe3a391c89edbee86fb2a4b349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873e6efe3a391c89edbee86fb2a4b349">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[11/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class R , class P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::duration&lt; R, P &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>dur</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::chrono::duration. </p>

</div>
</div>
<a id="a977c1527242726fecf6cb1f492683ca6" name="a977c1527242726fecf6cb1f492683ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977c1527242726fecf6cb1f492683ca6">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[12/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class C , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::time_point&lt; C, D &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>dur</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::chrono::time_point. </p>

</div>
</div>
<a id="a548257a795f8540c86333d0758fb99d5" name="a548257a795f8540c86333d0758fb99d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548257a795f8540c86333d0758fb99d5">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[13/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::complex&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>comp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing (save) for std::complex. </p>

</div>
</div>
<a id="a2e7e7370c46e4a819bd35fc1cdb856ad" name="a2e7e7370c46e4a819bd35fc1cdb856ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7e7370c46e4a819bd35fc1cdb856ad">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[14/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::deque&lt; T, A &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>deque</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::deque. </p>

</div>
</div>
<a id="a69af5df93ccfbbb3cc02575e3aeadbc6" name="a69af5df93ccfbbb3cc02575e3aeadbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69af5df93ccfbbb3cc02575e3aeadbc6">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[15/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; T, A &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>forward_list</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::forward_list all other types. </p>

</div>
</div>
<a id="ad5738ab4196d02509a5b69a58c7ca6ba" name="ad5738ab4196d02509a5b69a58c7ca6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5738ab4196d02509a5b69a58c7ca6ba">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[16/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; T, A &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>list</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::list. </p>

</div>
</div>
<a id="aba7424502dce9a6a12bc8b0c34c8fa04" name="aba7424502dce9a6a12bc8b0c34c8fa04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7424502dce9a6a12bc8b0c34c8fa04">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[17/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class C , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::multiset&lt; K, C, A &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>multiset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::multiset. </p>

</div>
</div>
<a id="ad1957ae53b8fc963c0ed3e831deae7ca" name="ad1957ae53b8fc963c0ed3e831deae7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1957ae53b8fc963c0ed3e831deae7ca">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[18/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class C , class Comp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::priority_queue&lt; T, C, Comp &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>priority_queue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::priority_queue. </p>

</div>
</div>
<a id="a196f5ec0e6eb126730ee5fb7339fb8be" name="a196f5ec0e6eb126730ee5fb7339fb8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196f5ec0e6eb126730ee5fb7339fb8be">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[19/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; T, C &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>queue</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::queue. </p>

</div>
</div>
<a id="a76a8cea063806602d60157cf1fb90878" name="a76a8cea063806602d60157cf1fb90878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a8cea063806602d60157cf1fb90878">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[20/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class C , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; K, C, A &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>set</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::set. </p>

</div>
</div>
<a id="a8f598f6d4fbee3b354eb83e597cb0ebe" name="a8f598f6d4fbee3b354eb83e597cb0ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f598f6d4fbee3b354eb83e597cb0ebe">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[21/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::shared_ptr for non polymorphic types. </p>

</div>
</div>
<a id="ad178feaa536101818dbed91f516d7a3d" name="ad178feaa536101818dbed91f516d7a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad178feaa536101818dbed91f516d7a3d">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[22/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_abstract&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::shared_ptr for polymorphic types, abstract. </p>

</div>
</div>
<a id="ad6d7ca1d179cff040e96656467c821c8" name="ad6d7ca1d179cff040e96656467c821c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d7ca1d179cff040e96656467c821c8">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[23/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;!std::is_abstract&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::shared_ptr for polymorphic types, not abstract. </p>

</div>
</div>
<a id="aca1f0d917ab00dd67f0b0e7d71737628" name="aca1f0d917ab00dd67f0b0e7d71737628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1f0d917ab00dd67f0b0e7d71737628">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[24/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; T, C &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>stack</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::stack. </p>

</div>
</div>
<a id="ac84435d57b8944c536bb585c6516df09" name="ac84435d57b8944c536bb585c6516df09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84435d57b8944c536bb585c6516df09">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[25/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T, D &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::unique_ptr for non polymorphic types. </p>

</div>
</div>
<a id="a65bf933f694e73578a268e7566c01443" name="a65bf933f694e73578a268e7566c01443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bf933f694e73578a268e7566c01443">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[26/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_abstract&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T, D &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::unique_ptr for polymorphic types that are abstract. </p>

</div>
</div>
<a id="a9e704d8ad2170ff91ad710ed776d0727" name="a9e704d8ad2170ff91ad710ed776d0727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e704d8ad2170ff91ad710ed776d0727">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[27/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class D &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;!std::is_abstract&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; T, D &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::unique_ptr for polymorphic types, not abstract. </p>

</div>
</div>
<a id="a4385e91ff798d9c5f8c336470011b889" name="a4385e91ff798d9c5f8c336470011b889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4385e91ff798d9c5f8c336470011b889">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[28/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class H , class KE , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_multiset&lt; K, H, KE, A &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>unordered_multiset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::unordered_multiset. </p>

</div>
</div>
<a id="a220a6067b52ed669c0c151d76567b561" name="a220a6067b52ed669c0c151d76567b561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220a6067b52ed669c0c151d76567b561">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[29/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class K , class H , class KE , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; K, H, KE, A &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>unordered_set</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::unordered_set. </p>

</div>
</div>
<a id="afa97ef85d3c72b1bb9398c8c197fdd57" name="afa97ef85d3c72b1bb9398c8c197fdd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa97ef85d3c72b1bb9398c8c197fdd57">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[30/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::valarray&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>valarray</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::valarray arithmetic types, using binary serialization, if supported. </p>

</div>
</div>
<a id="a8433d3fefce97949c3b895a50f9a8beb" name="a8433d3fefce97949c3b895a50f9a8beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8433d3fefce97949c3b895a50f9a8beb">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[31/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::valarray&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>valarray</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::valarray all other types. </p>

</div>
</div>
<a id="a216f04eb0fd673671c399e76270d7f5c" name="a216f04eb0fd673671c399e76270d7f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216f04eb0fd673671c399e76270d7f5c">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[32/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , typename VariantType1 , typename... VariantTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::variant&lt; VariantType1, VariantTypes... &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>variant</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::variant. </p>

</div>
</div>
<a id="a76b613c5fc7ae5ec8f8216a6337955a7" name="a76b613c5fc7ae5ec8f8216a6337955a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b613c5fc7ae5ec8f8216a6337955a7">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[33/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool, A &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for bool vector types. </p>

</div>
</div>
<a id="adb789479aa9deae7b63d249f6dccccaf" name="adb789479aa9deae7b63d249f6dccccaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb789479aa9deae7b63d249f6dccccaf">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[34/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &amp;&amp;!std::is_same&lt; T, bool &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, A &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for std::vectors of arithmetic (but not bool) using binary serialization, if supported. </p>

</div>
</div>
<a id="a4ae26efa958e82169d5f813bda0ad1c5" name="a4ae26efa958e82169d5f813bda0ad1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae26efa958e82169d5f813bda0ad1c5">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[35/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(!<a class="el" href="structcereal_1_1traits_1_1is__output__serializable.html">traits::is_output_serializable</a>&lt; <a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt;, Archive &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>)&amp;&amp;!std::is_same&lt; T, bool &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T, A &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>vector</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for non-arithmetic vector types. </p>

</div>
</div>
<a id="a6ac5820fd45ce7b235c753be49a2913c" name="a6ac5820fd45ce7b235c753be49a2913c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac5820fd45ce7b235c753be49a2913c">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[36/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::weak_ptr&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::weak_ptr for non polymorphic types. </p>

</div>
</div>
<a id="a6abec1a5b79a96fac6e8a9452d6d5efc" name="a6abec1a5b79a96fac6e8a9452d6d5efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abec1a5b79a96fac6e8a9452d6d5efc">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[37/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_polymorphic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::weak_ptr&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving std::weak_ptr for polymorphic types. </p>

</div>
</div>
<a id="a189662781a0f3b710901f892d87792d5" name="a189662781a0f3b710901f892d87792d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a189662781a0f3b710901f892d87792d5">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[38/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_binary_output_archive.html">BinaryOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>bd</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving binary data. </p>

</div>
</div>
<a id="a2287a243ece679a7cfad54641c790ecc" name="a2287a243ece679a7cfad54641c790ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2287a243ece679a7cfad54641c790ecc">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[39/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_binary_output_archive.html">BinaryOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for POD types to binary. </p>

</div>
</div>
<a id="a66b30facce64dd6f270097f144f9ffde" name="a66b30facce64dd6f270097f144f9ffde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b30facce64dd6f270097f144f9ffde">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[40/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving SizeTags to JSON. </p>

</div>
</div>
<a id="a049f4acf75e647cce18b4b98c9037cfb" name="a049f4acf75e647cce18b4b98c9037cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049f4acf75e647cce18b4b98c9037cfb">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[41/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing NVP types to JSON. </p>

</div>
</div>
<a id="a94cbcd5c53fd79f0f97b816820b013ff" name="a94cbcd5c53fd79f0f97b816820b013ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94cbcd5c53fd79f0f97b816820b013ff">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[42/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>saving string to JSON </p>

</div>
</div>
<a id="ad05ab834a18302c852181802b22d30ec" name="ad05ab834a18302c852181802b22d30ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05ab834a18302c852181802b22d30ec">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[43/50]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t const &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for nullptr to JSON. </p>

</div>
</div>
<a id="a272e0c7b90d4591e8e0a13ebb17ca909" name="a272e0c7b90d4591e8e0a13ebb17ca909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272e0c7b90d4591e8e0a13ebb17ca909">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[44/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for arithmetic to JSON. </p>

</div>
</div>
<a id="a4ba55a1d28e2db9a09ba767a4b1f16d7" name="a4ba55a1d28e2db9a09ba767a4b1f16d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba55a1d28e2db9a09ba767a4b1f16d7">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[45/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_portable_binary_output_archive.html">PortableBinaryOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcereal_1_1_binary_data.html">BinaryData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>bd</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving binary data to portable binary. </p>

</div>
</div>
<a id="aa2a82fca196f0aaac88c78a46ab52475" name="aa2a82fca196f0aaac88c78a46ab52475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a82fca196f0aaac88c78a46ab52475">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[46/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_portable_binary_output_archive.html">PortableBinaryOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for POD types to portable binary. </p>

</div>
</div>
<a id="a1703ea149fc65a4d7851fa85823287b2" name="a1703ea149fc65a4d7851fa85823287b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1703ea149fc65a4d7851fa85823287b2">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[47/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving SizeTags to XML. </p>

</div>
</div>
<a id="a9a252f7731760e1186c3c552f640fc7b" name="a9a252f7731760e1186c3c552f640fc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a252f7731760e1186c3c552f640fc7b">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[48/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving NVP types to XML. </p>

</div>
</div>
<a id="a63696aa0de3dc95bc27f97bf455d15e8" name="a63696aa0de3dc95bc27f97bf455d15e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63696aa0de3dc95bc27f97bf455d15e8">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[49/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>saving string to xml </p>

</div>
</div>
<a id="ac6311a745c3a12848550eff8fba71f31" name="ac6311a745c3a12848550eff8fba71f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6311a745c3a12848550eff8fba71f31">&#9670;&#160;</a></span>CEREAL_SAVE_FUNCTION_NAME() <span class="overload">[50/50]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt; std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SAVE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for POD types to xml. </p>

</div>
</div>
<a id="aa282de424af3d15ebfd094a216029149" name="aa282de424af3d15ebfd094a216029149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa282de424af3d15ebfd094a216029149">&#9670;&#160;</a></span>CEREAL_SAVE_MINIMAL_FUNCTION_NAME()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="classcereal_1_1common__detail_1_1is__enum.html">common_detail::is_enum</a>&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, typenamecommon_detail::is_enum&lt; T &gt;::base_type &gt;::type cereal::CEREAL_SAVE_MINIMAL_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive const &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for enum types. </p>

</div>
</div>
<a id="a0e33aa2fc1bde7f59e9796f922cee3b9" name="a0e33aa2fc1bde7f59e9796f922cee3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e33aa2fc1bde7f59e9796f922cee3b9">&#9670;&#160;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::monostate const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serializing a std::monostate. </p>

</div>
</div>
<a id="a676a85ac8cfcd512a743f930a10b6770" name="a676a85ac8cfcd512a743f930a10b6770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676a85ac8cfcd512a743f930a10b6770">&#9670;&#160;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for raw pointers. </p>
<p>This exists only to throw a static_assert to let users know we don't support raw pointers. </p>

</div>
</div>
<a id="a64ec0a04e5dc57a58de5e78b5a87b8d3" name="a64ec0a04e5dc57a58de5e78b5a87b8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ec0a04e5dc57a58de5e78b5a87b8d3">&#9670;&#160;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing NVP types to binary. </p>
<p>Serializing NVP types to portable binary. </p>

</div>
</div>
<a id="ac5fb9b1468920e7e23cb2817e65fed4a" name="ac5fb9b1468920e7e23cb2817e65fed4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fb9b1468920e7e23cb2817e65fed4a">&#9670;&#160;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing SizeTags to binary. </p>
<p>Serializing SizeTags to portable binary. </p>

</div>
</div>
<a id="a83c80c9e74c022531318b7df731c1f73" name="a83c80c9e74c022531318b7df731c1f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c80c9e74c022531318b7df731c1f73">&#9670;&#160;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T1 , class T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; T1, T2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>pair</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing for std::pair. </p>

</div>
</div>
<a id="a660edef0c6b018675e109062d459dc82" name="a660edef0c6b018675e109062d459dc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660edef0c6b018675e109062d459dc82">&#9670;&#160;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class ... Types&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Types... &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tuple</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializing for std::tuple. </p>

</div>
</div>
<a id="a03728f69af179b3cb5e2ec9131b8ccc3" name="a03728f69af179b3cb5e2ec9131b8ccc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03728f69af179b3cb5e2ec9131b8ccc3">&#9670;&#160;</a></span>CEREAL_SERIALIZE_FUNCTION_NAME() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_array&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, void &gt;::type cereal::CEREAL_SERIALIZE_FUNCTION_NAME </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>array</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serialization for C style arrays. </p>

</div>
</div>
<a id="a1153b7ce7ffbb86e2c81e076a252938e" name="a1153b7ce7ffbb86e2c81e076a252938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1153b7ce7ffbb86e2c81e076a252938e">&#9670;&#160;</a></span>epilogue() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a type is serialized to tear down any special archive state for processing some type </p>

</div>
</div>
<a id="a7ae425e0a66c44b7d39b16d0a6a7f0d9" name="a7ae425e0a66c44b7d39b16d0a6a7f0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae425e0a66c44b7d39b16d0a6a7f0d9">&#9670;&#160;</a></span>epilogue() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for deferred for JSON archives. </p>
<p>Do nothing for the defer wrapper </p>

</div>
</div>
<a id="a99326c431920835d61e5bfc51b865f22" name="a99326c431920835d61e5bfc51b865f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99326c431920835d61e5bfc51b865f22">&#9670;&#160;</a></span>epilogue() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for NVPs for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="acb582097a98c0558c1a6b3cf0ef52270" name="acb582097a98c0558c1a6b3cf0ef52270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb582097a98c0558c1a6b3cf0ef52270">&#9670;&#160;</a></span>epilogue() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for SizeTags for JSON archives. </p>

</div>
</div>
<a id="a733225f7be628b7c4dfca463d6a44253" name="a733225f7be628b7c4dfca463d6a44253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733225f7be628b7c4dfca463d6a44253">&#9670;&#160;</a></span>epilogue() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for strings for JSON archives. </p>

</div>
</div>
<a id="a9198bda1f28453a9ead2f8999e5fb449" name="a9198bda1f28453a9ead2f8999e5fb449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9198bda1f28453a9ead2f8999e5fb449">&#9670;&#160;</a></span>epilogue() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for arithmetic types for JSON archives. </p>

</div>
</div>
<a id="a5cdc10b14dce9340a8df6cb18ac74554" name="a5cdc10b14dce9340a8df6cb18ac74554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdc10b14dce9340a8df6cb18ac74554">&#9670;&#160;</a></span>epilogue() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>, <a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for all other types other for JSON archives. </p>
<p>Epilogue for arithmetic types for JSON archives. </p>

</div>
</div>
<a id="ae0c0c3b1ea7aadc84af34b815bfad6a6" name="ae0c0c3b1ea7aadc84af34b815bfad6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c0c3b1ea7aadc84af34b815bfad6a6">&#9670;&#160;</a></span>epilogue() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for deferred for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="a3bec173adc6146ecc712921c2d257ade" name="a3bec173adc6146ecc712921c2d257ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bec173adc6146ecc712921c2d257ade">&#9670;&#160;</a></span>epilogue() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for NVPs for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="ab92526cf5d3f4a642d918a027d2e4567" name="ab92526cf5d3f4a642d918a027d2e4567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92526cf5d3f4a642d918a027d2e4567">&#9670;&#160;</a></span>epilogue() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for SizeTags for JSON archives. </p>
<p>SizeTags are strictly ignored for JSON </p>

</div>
</div>
<a id="aa06f0f66ced9dd9c85377ba61054df94" name="aa06f0f66ced9dd9c85377ba61054df94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06f0f66ced9dd9c85377ba61054df94">&#9670;&#160;</a></span>epilogue() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for strings for JSON archives. </p>

</div>
</div>
<a id="ad67f92a71f4318dd69e6dec516fe57dd" name="ad67f92a71f4318dd69e6dec516fe57dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67f92a71f4318dd69e6dec516fe57dd">&#9670;&#160;</a></span>epilogue() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for arithmetic types for JSON archives. </p>

</div>
</div>
<a id="abb6adc568591c0a525f2c16ea5912c5b" name="abb6adc568591c0a525f2c16ea5912c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6adc568591c0a525f2c16ea5912c5b">&#9670;&#160;</a></span>epilogue() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for all other types other for JSON archives (except minimal types) </p>
<p>Epilogue for arithmetic types for JSON archives.</p>
<p>Finishes the node created in the prologue</p>
<p>Minimal types do not start or finish nodes </p>

</div>
</div>
<a id="a70bbce1604367ea45c07dc677186ed64" name="a70bbce1604367ea45c07dc677186ed64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bbce1604367ea45c07dc677186ed64">&#9670;&#160;</a></span>epilogue() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for deferred for XML archives. </p>
<p>Do nothing for the defer wrapper </p>

</div>
</div>
<a id="a5d1af5fa5a466ad0cd89513aab823b80" name="a5d1af5fa5a466ad0cd89513aab823b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1af5fa5a466ad0cd89513aab823b80">&#9670;&#160;</a></span>epilogue() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for NVPs for XML input archives. </p>

</div>
</div>
<a id="ada513bbfcf8c1996e6f7a439f129a208" name="ada513bbfcf8c1996e6f7a439f129a208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada513bbfcf8c1996e6f7a439f129a208">&#9670;&#160;</a></span>epilogue() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae06e3f89a66231db109db984a87e0cfd" name="ae06e3f89a66231db109db984a87e0cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06e3f89a66231db109db984a87e0cfd">&#9670;&#160;</a></span>epilogue() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::DisableIf&lt; <a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>, <a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||<a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for all other types other for XML output archives (except minimal types) </p>

</div>
</div>
<a id="acb1f17a3cae999a9be34889fd2c509a0" name="acb1f17a3cae999a9be34889fd2c509a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1f17a3cae999a9be34889fd2c509a0">&#9670;&#160;</a></span>epilogue() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for deferred for XML archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="a906ef65c3ab455598f768431bcd5f37d" name="a906ef65c3ab455598f768431bcd5f37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906ef65c3ab455598f768431bcd5f37d">&#9670;&#160;</a></span>epilogue() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for NVPs for XML output archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="ac3700f36066026da589faa60fed7ca53" name="ac3700f36066026da589faa60fed7ca53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3700f36066026da589faa60fed7ca53">&#9670;&#160;</a></span>epilogue() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for SizeTags for XML output archives. </p>
<p>SizeTags do not start or finish nodes </p>

</div>
</div>
<a id="a16ca55f7d5556527de1584198ea3c414" name="a16ca55f7d5556527de1584198ea3c414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ca55f7d5556527de1584198ea3c414">&#9670;&#160;</a></span>epilogue() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::DisableIf&lt; <a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||<a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::epilogue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Epilogue for all other types other for XML output archives (except minimal types) </p>
<p>Finishes the node created in the prologue</p>
<p>Minimal types do not start or end nodes </p>

</div>
</div>
<a id="a72323b9f6443491b5fe35133c22b7060" name="a72323b9f6443491b5fe35133c22b7060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72323b9f6443491b5fe35133c22b7060">&#9670;&#160;</a></span>make_map_item()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KeyType , class ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcereal_1_1_map_item.html">MapItem</a>&lt; KeyType, ValueType &gt; cereal::make_map_item </td>
          <td>(</td>
          <td class="paramtype">KeyType &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structcereal_1_1_map_item.html" title="A wrapper around a key and value for serializing data into maps.">MapItem</a> so that human readable archives will group keys and values together. </p>

</div>
</div>
<a id="a8093b5f7cfd618fae6350ef7b2c09453" name="a8093b5f7cfd618fae6350ef7b2c09453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8093b5f7cfd618fae6350ef7b2c09453">&#9670;&#160;</a></span>prologue() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called before a type is serialized to set up any special archive state for processing some type</p>
<p>If designing a serializer that needs to set up any kind of special state or output extra information for a type, specialize this function for the archive type and the types that require the extra information. </p>

</div>
</div>
<a id="a6ff01a6c38b02073beb88b56f80b0ba7" name="a6ff01a6c38b02073beb88b56f80b0ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff01a6c38b02073beb88b56f80b0ba7">&#9670;&#160;</a></span>prologue() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for deferred data for JSON archives. </p>

</div>
</div>
<a id="ae77f745fd34dd83fa6543e0fa478bdfa" name="ae77f745fd34dd83fa6543e0fa478bdfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77f745fd34dd83fa6543e0fa478bdfa">&#9670;&#160;</a></span>prologue() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for NVPs for JSON archives. </p>

</div>
</div>
<a id="accec39647fd17ad5470e42a5c371701c" name="accec39647fd17ad5470e42a5c371701c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accec39647fd17ad5470e42a5c371701c">&#9670;&#160;</a></span>prologue() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for SizeTags for JSON archives. </p>

</div>
</div>
<a id="a4dde17944a1c24885e39ff673b402841" name="a4dde17944a1c24885e39ff673b402841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dde17944a1c24885e39ff673b402841">&#9670;&#160;</a></span>prologue() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for strings for JSON archives. </p>

</div>
</div>
<a id="aef075a9d94a926df8ba17689914233e2" name="aef075a9d94a926df8ba17689914233e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef075a9d94a926df8ba17689914233e2">&#9670;&#160;</a></span>prologue() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for arithmetic types for JSON archives. </p>

</div>
</div>
<a id="af88fce78fe97297ab4d22a607fee1e07" name="af88fce78fe97297ab4d22a607fee1e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88fce78fe97297ab4d22a607fee1e07">&#9670;&#160;</a></span>prologue() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>, <a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_input_archive.html">JSONInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for all other types for JSON archives. </p>
<p>Prologue for arithmetic types for JSON archives. </p>

</div>
</div>
<a id="ab4eb0997ec3815e2be77c35351d02cf7" name="ab4eb0997ec3815e2be77c35351d02cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4eb0997ec3815e2be77c35351d02cf7">&#9670;&#160;</a></span>prologue() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for deferred data for JSON archives. </p>
<p>Do nothing for the defer wrapper </p>

</div>
</div>
<a id="ac267b8915a13f4433fc25aa9d310ee40" name="ac267b8915a13f4433fc25aa9d310ee40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac267b8915a13f4433fc25aa9d310ee40">&#9670;&#160;</a></span>prologue() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for NVPs for JSON archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="a5f7ec98da774f9e0af596620859d8ccb" name="a5f7ec98da774f9e0af596620859d8ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7ec98da774f9e0af596620859d8ccb">&#9670;&#160;</a></span>prologue() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for SizeTags for JSON archives. </p>
<p>SizeTags are strictly ignored for JSON, they just indicate that the current node should be made into an array </p>

</div>
</div>
<a id="adacd1c15f7ed1793453e56a675bd0a78" name="adacd1c15f7ed1793453e56a675bd0a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacd1c15f7ed1793453e56a675bd0a78">&#9670;&#160;</a></span>prologue() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for strings for JSON archives. </p>

</div>
</div>
<a id="a956c4c0578baf265811497c965c4a382" name="a956c4c0578baf265811497c965c4a382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956c4c0578baf265811497c965c4a382">&#9670;&#160;</a></span>prologue() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for arithmetic types for JSON archives. </p>

</div>
</div>
<a id="aba2924cd871a88c20023171f74a68d39" name="aba2924cd871a88c20023171f74a68d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2924cd871a88c20023171f74a68d39">&#9670;&#160;</a></span>prologue() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt;!std::is_arithmetic&lt; T &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>, !<a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_j_s_o_n_output_archive.html">JSONOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for all other types for JSON archives (except minimal types) </p>
<p>Prologue for arithmetic types for JSON archives.</p>
<p>Starts a new node, named either automatically or by some NVP, that may be given data by the type about to be archived</p>
<p>Minimal types do not start or finish nodes </p>

</div>
</div>
<a id="adf285317856bf80daaa225e171d8d951" name="adf285317856bf80daaa225e171d8d951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf285317856bf80daaa225e171d8d951">&#9670;&#160;</a></span>prologue() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for deferred data for XML archives. </p>

</div>
</div>
<a id="a06224101dfaf6979418326a7664e13e2" name="a06224101dfaf6979418326a7664e13e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06224101dfaf6979418326a7664e13e2">&#9670;&#160;</a></span>prologue() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for NVPs for XML input archives. </p>

</div>
</div>
<a id="aa25e6485f450649b931e07e0f6384a76" name="aa25e6485f450649b931e07e0f6384a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25e6485f450649b931e07e0f6384a76">&#9670;&#160;</a></span>prologue() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ea2b824c9d003b9e2b36473db1d22c0" name="a7ea2b824c9d003b9e2b36473db1d22c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea2b824c9d003b9e2b36473db1d22c0">&#9670;&#160;</a></span>prologue() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::DisableIf&lt; <a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>, <a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||<a class="el" href="structcereal_1_1traits_1_1has__minimal__input__serialization.html">traits::has_minimal_input_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for all other types for XML input archives (except minimal types) </p>

</div>
</div>
<a id="a6124c7acd34d3740cbedd39559da73c3" name="a6124c7acd34d3740cbedd39559da73c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6124c7acd34d3740cbedd39559da73c3">&#9670;&#160;</a></span>prologue() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_deferred_data.html">DeferredData</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for deferred data for XML archives. </p>
<p>Do nothing for the defer wrapper </p>

</div>
</div>
<a id="a2582cc8477f9482910fc5733e13f75f7" name="a2582cc8477f9482910fc5733e13f75f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2582cc8477f9482910fc5733e13f75f7">&#9670;&#160;</a></span>prologue() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_name_value_pair.html">NameValuePair</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for NVPs for XML output archives. </p>
<p>NVPs do not start or finish nodes - they just set up the names </p>

</div>
</div>
<a id="adbb541e9594201d78a04cb11ad806ba0" name="adbb541e9594201d78a04cb11ad806ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb541e9594201d78a04cb11ad806ba0">&#9670;&#160;</a></span>prologue() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_size_tag.html">SizeTag</a>&lt; T &gt; const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for SizeTags for XML output archives. </p>
<p>SizeTags do not start or finish nodes </p>

</div>
</div>
<a id="af751c02a4443b571fee21416a4b899c1" name="af751c02a4443b571fee21416a4b899c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af751c02a4443b571fee21416a4b899c1">&#9670;&#160;</a></span>prologue() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::DisableIf&lt; <a class="el" href="structcereal_1_1traits_1_1has__minimal__base__class__serialization.html">traits::has_minimal_base_class_serialization</a>&lt; T, <a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>, <a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a>||<a class="el" href="structcereal_1_1traits_1_1has__minimal__output__serialization.html">traits::has_minimal_output_serialization</a>&lt; T, <a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &gt;<a class="el" href="pointer_8h.html#a32aff7c6c4cd253fdf6563677afab5ce">::value</a> &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::prologue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1_x_m_l_output_archive.html">XMLOutputArchive</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ar</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prologue for all other types for XML output archives (except minimal types) </p>
<p>Starts a new node, named either automatically or by some NVP, that may be given data by the type about to be archived</p>
<p>Minimal types do not start or end nodes </p>

</div>
</div>
<a id="a02f9cfc9a4055c8a49eb050b02cd3357" name="a02f9cfc9a4055c8a49eb050b02cd3357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f9cfc9a4055c8a49eb050b02cd3357">&#9670;&#160;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;</td>          <td class="paramname"><span class="paramname">, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::less&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saving for std::less. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
