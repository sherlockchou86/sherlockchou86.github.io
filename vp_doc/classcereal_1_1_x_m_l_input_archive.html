<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>VideoPipe: cereal::XMLInputArchive Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">VideoPipe
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecereal.html">cereal</a></li><li class="navelem"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classcereal_1_1_x_m_l_input_archive-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">cereal::XMLInputArchive Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An output archive designed to load data from XML.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="xml_8hpp_source.html">xml.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cereal::XMLInputArchive:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcereal_1_1_x_m_l_input_archive.png" usemap="#cereal::XMLInputArchive_map" alt=""/>
  <map id="cereal::XMLInputArchive_map" name="cereal::XMLInputArchive_map">
<area href="classcereal_1_1_input_archive.html" alt="cereal::InputArchive&lt; XMLInputArchive &gt;" shape="rect" coords="0,56,249,80"/>
<area href="structcereal_1_1traits_1_1_text_archive.html" title="Type traits only struct used to mark an archive as human readable (text based)" alt="cereal::traits::TextArchive" shape="rect" coords="259,56,508,80"/>
<area href="classcereal_1_1detail_1_1_input_archive_base.html" alt="cereal::detail::InputArchiveBase" shape="rect" coords="0,0,249,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcereal_1_1_x_m_l_input_archive_1_1_node_info.html">NodeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that contains metadata about a node.  <a href="structcereal_1_1_x_m_l_input_archive_1_1_node_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Common Functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Common use cases for directly interacting with an <a class="el" href="classcereal_1_1_x_m_l_input_archive.html" title="An output archive designed to load data from XML.">XMLInputArchive</a> </p>
</div></td></tr>
<tr class="memitem:ab641ded4033d8e998e41dd002ece9184" id="r_ab641ded4033d8e998e41dd002ece9184"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab641ded4033d8e998e41dd002ece9184">XMLInputArchive</a> (std::istream &amp;stream)</td></tr>
<tr class="memdesc:ab641ded4033d8e998e41dd002ece9184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct, reading in from the provided stream.  <br /></td></tr>
<tr class="separator:ab641ded4033d8e998e41dd002ece9184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe95a5639def701ef58187ac9190868" id="r_adbe95a5639def701ef58187ac9190868"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbe95a5639def701ef58187ac9190868">~XMLInputArchive</a> () <a class="el" href="macros_8hpp.html#a6c37b2307b83bbe2a3de58d78a2b8c0b">CEREAL_NOEXCEPT</a>=default</td></tr>
<tr class="separator:adbe95a5639def701ef58187ac9190868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974ecacf6a6411fb98e89182011b4b55" id="r_a974ecacf6a6411fb98e89182011b4b55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a974ecacf6a6411fb98e89182011b4b55">loadBinaryValue</a> (void *data, size_t size, const char *name=nullptr)</td></tr>
<tr class="memdesc:a974ecacf6a6411fb98e89182011b4b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads some binary data, encoded as a <a class="el" href="namespacecereal_1_1base64.html">base64</a> string, optionally specified by some name.  <br /></td></tr>
<tr class="separator:a974ecacf6a6411fb98e89182011b4b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcereal_1_1_input_archive"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classcereal_1_1_input_archive')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcereal_1_1_input_archive.html">cereal::InputArchive&lt; XMLInputArchive &gt;</a></td></tr>
<tr class="memitem:a76455fba49795d1676664f634918c580 inherit pub_methods_classcereal_1_1_input_archive" id="r_a76455fba49795d1676664f634918c580"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_input_archive.html#a76455fba49795d1676664f634918c580">InputArchive</a> (<a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> *const derived)</td></tr>
<tr class="memdesc:a76455fba49795d1676664f634918c580 inherit pub_methods_classcereal_1_1_input_archive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the output archive.  <br /></td></tr>
<tr class="separator:a76455fba49795d1676664f634918c580 inherit pub_methods_classcereal_1_1_input_archive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c35edcb5a55280e3ac0628d327f2f49 inherit pub_methods_classcereal_1_1_input_archive" id="r_a9c35edcb5a55280e3ac0628d327f2f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcereal_1_1_input_archive.html">InputArchive</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_input_archive.html#a9c35edcb5a55280e3ac0628d327f2f49">operator=</a> (<a class="el" href="classcereal_1_1_input_archive.html">InputArchive</a> const &amp;)=delete</td></tr>
<tr class="separator:a9c35edcb5a55280e3ac0628d327f2f49 inherit pub_methods_classcereal_1_1_input_archive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ec8f1eab19703af75612e32d0a95b4 inherit pub_methods_classcereal_1_1_input_archive" id="r_a74ec8f1eab19703af75612e32d0a95b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_input_archive.html#a74ec8f1eab19703af75612e32d0a95b4">operator()</a> (Types &amp;&amp;... args)</td></tr>
<tr class="memdesc:a74ec8f1eab19703af75612e32d0a95b4 inherit pub_methods_classcereal_1_1_input_archive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes all passed in data.  <br /></td></tr>
<tr class="separator:a74ec8f1eab19703af75612e32d0a95b4 inherit pub_methods_classcereal_1_1_input_archive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846b9482bf620966e2fa91921251a307 inherit pub_methods_classcereal_1_1_input_archive" id="r_a846b9482bf620966e2fa91921251a307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_input_archive.html#a846b9482bf620966e2fa91921251a307">serializeDeferments</a> ()</td></tr>
<tr class="memdesc:a846b9482bf620966e2fa91921251a307 inherit pub_methods_classcereal_1_1_input_archive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes any data marked for deferment using defer.  <br /></td></tr>
<tr class="separator:a846b9482bf620966e2fa91921251a307 inherit pub_methods_classcereal_1_1_input_archive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973b6c5a6fdc65ab2e5420416cf33130 inherit pub_methods_classcereal_1_1_input_archive" id="r_a973b6c5a6fdc65ab2e5420416cf33130"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_input_archive.html#a973b6c5a6fdc65ab2e5420416cf33130">getSharedPointer</a> (std::uint32_t const id)</td></tr>
<tr class="memdesc:a973b6c5a6fdc65ab2e5420416cf33130 inherit pub_methods_classcereal_1_1_input_archive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a shared pointer given a unique key for it.  <br /></td></tr>
<tr class="separator:a973b6c5a6fdc65ab2e5420416cf33130 inherit pub_methods_classcereal_1_1_input_archive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8c43c2803faa0b78cfb42e10c91d93 inherit pub_methods_classcereal_1_1_input_archive" id="r_a5a8c43c2803faa0b78cfb42e10c91d93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_input_archive.html#a5a8c43c2803faa0b78cfb42e10c91d93">registerSharedPointer</a> (std::uint32_t const id, std::shared_ptr&lt; void &gt; ptr)</td></tr>
<tr class="memdesc:a5a8c43c2803faa0b78cfb42e10c91d93 inherit pub_methods_classcereal_1_1_input_archive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a shared pointer to its unique identifier.  <br /></td></tr>
<tr class="separator:a5a8c43c2803faa0b78cfb42e10c91d93 inherit pub_methods_classcereal_1_1_input_archive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d39247b893f26eecc863a7b321e6a00 inherit pub_methods_classcereal_1_1_input_archive" id="r_a2d39247b893f26eecc863a7b321e6a00"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_input_archive.html#a2d39247b893f26eecc863a7b321e6a00">getPolymorphicName</a> (std::uint32_t const id)</td></tr>
<tr class="memdesc:a2d39247b893f26eecc863a7b321e6a00 inherit pub_methods_classcereal_1_1_input_archive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the string for a polymorphic type given a unique key for it.  <br /></td></tr>
<tr class="separator:a2d39247b893f26eecc863a7b321e6a00 inherit pub_methods_classcereal_1_1_input_archive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6602c484b49376ad1c392719d02ef56 inherit pub_methods_classcereal_1_1_input_archive" id="r_ae6602c484b49376ad1c392719d02ef56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_input_archive.html#ae6602c484b49376ad1c392719d02ef56">registerPolymorphicName</a> (std::uint32_t const id, std::string const &amp;name)</td></tr>
<tr class="memdesc:ae6602c484b49376ad1c392719d02ef56 inherit pub_methods_classcereal_1_1_input_archive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a polymorphic name string to its unique identifier.  <br /></td></tr>
<tr class="separator:ae6602c484b49376ad1c392719d02ef56 inherit pub_methods_classcereal_1_1_input_archive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af116f10b84706be1da9cffa1ecf51243 inherit pub_methods_classcereal_1_1_input_archive" id="r_af116f10b84706be1da9cffa1ecf51243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_input_archive.html#af116f10b84706be1da9cffa1ecf51243">operator&amp;</a> (T &amp;&amp;arg)</td></tr>
<tr class="memdesc:af116f10b84706be1da9cffa1ecf51243 inherit pub_methods_classcereal_1_1_input_archive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes passed in data.  <br /></td></tr>
<tr class="separator:af116f10b84706be1da9cffa1ecf51243 inherit pub_methods_classcereal_1_1_input_archive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ecef5deaf12b27f43b7956a8416507 inherit pub_methods_classcereal_1_1_input_archive" id="r_a08ecef5deaf12b27f43b7956a8416507"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcereal_1_1_x_m_l_input_archive.html">XMLInputArchive</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_input_archive.html#a08ecef5deaf12b27f43b7956a8416507">operator&gt;&gt;</a> (T &amp;&amp;arg)</td></tr>
<tr class="memdesc:a08ecef5deaf12b27f43b7956a8416507 inherit pub_methods_classcereal_1_1_input_archive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes passed in data.  <br /></td></tr>
<tr class="separator:a08ecef5deaf12b27f43b7956a8416507 inherit pub_methods_classcereal_1_1_input_archive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcereal_1_1detail_1_1_input_archive_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classcereal_1_1detail_1_1_input_archive_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcereal_1_1detail_1_1_input_archive_base.html">cereal::detail::InputArchiveBase</a></td></tr>
<tr class="memitem:a15481bb65b50e3b07b430fc0f2a80d69 inherit pub_methods_classcereal_1_1detail_1_1_input_archive_base" id="r_a15481bb65b50e3b07b430fc0f2a80d69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1detail_1_1_input_archive_base.html#a15481bb65b50e3b07b430fc0f2a80d69">InputArchiveBase</a> ()=default</td></tr>
<tr class="separator:a15481bb65b50e3b07b430fc0f2a80d69 inherit pub_methods_classcereal_1_1detail_1_1_input_archive_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3165c8d75cc83037a6f25c5d3bf3d4 inherit pub_methods_classcereal_1_1detail_1_1_input_archive_base" id="r_a6c3165c8d75cc83037a6f25c5d3bf3d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1detail_1_1_input_archive_base.html#a6c3165c8d75cc83037a6f25c5d3bf3d4">InputArchiveBase</a> (<a class="el" href="classcereal_1_1detail_1_1_input_archive_base.html">InputArchiveBase</a> &amp;&amp;) <a class="el" href="macros_8hpp.html#a6c37b2307b83bbe2a3de58d78a2b8c0b">CEREAL_NOEXCEPT</a></td></tr>
<tr class="separator:a6c3165c8d75cc83037a6f25c5d3bf3d4 inherit pub_methods_classcereal_1_1detail_1_1_input_archive_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e95c8dcfa3b1d90adfc46bd322fcb1 inherit pub_methods_classcereal_1_1detail_1_1_input_archive_base" id="r_a92e95c8dcfa3b1d90adfc46bd322fcb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcereal_1_1detail_1_1_input_archive_base.html">InputArchiveBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1detail_1_1_input_archive_base.html#a92e95c8dcfa3b1d90adfc46bd322fcb1">operator=</a> (<a class="el" href="classcereal_1_1detail_1_1_input_archive_base.html">InputArchiveBase</a> &amp;&amp;) <a class="el" href="macros_8hpp.html#a6c37b2307b83bbe2a3de58d78a2b8c0b">CEREAL_NOEXCEPT</a></td></tr>
<tr class="separator:a92e95c8dcfa3b1d90adfc46bd322fcb1 inherit pub_methods_classcereal_1_1detail_1_1_input_archive_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee11504d4d8feb2fafb70e0274313e6 inherit pub_methods_classcereal_1_1detail_1_1_input_archive_base" id="r_a5ee11504d4d8feb2fafb70e0274313e6"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1detail_1_1_input_archive_base.html#a5ee11504d4d8feb2fafb70e0274313e6">~InputArchiveBase</a> () <a class="el" href="macros_8hpp.html#a6c37b2307b83bbe2a3de58d78a2b8c0b">CEREAL_NOEXCEPT</a>=default</td></tr>
<tr class="separator:a5ee11504d4d8feb2fafb70e0274313e6 inherit pub_methods_classcereal_1_1detail_1_1_input_archive_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Internal Functionality</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>Functionality designed for use by those requiring control over the inner mechanisms of the <a class="el" href="classcereal_1_1_x_m_l_input_archive.html" title="An output archive designed to load data from XML.">XMLInputArchive</a> </p>
</td></tr>
<tr class="memitem:acd31f5302f9d5d9046b4b1425e370fc6" id="r_acd31f5302f9d5d9046b4b1425e370fc6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acd31f5302f9d5d9046b4b1425e370fc6"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a></td></tr>
<tr class="memdesc:acd31f5302f9d5d9046b4b1425e370fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a type best represented as an int from the current top node.  <br /></td></tr>
<tr class="separator:acd31f5302f9d5d9046b4b1425e370fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c8399e6e6651126aaf5d38631c14d0" id="r_a96c8399e6e6651126aaf5d38631c14d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96c8399e6e6651126aaf5d38631c14d0">startNode</a> ()</td></tr>
<tr class="memdesc:a96c8399e6e6651126aaf5d38631c14d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares to start reading the next node.  <br /></td></tr>
<tr class="separator:a96c8399e6e6651126aaf5d38631c14d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f0c412f74f3b538efac94886005b44" id="r_a06f0c412f74f3b538efac94886005b44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06f0c412f74f3b538efac94886005b44">finishNode</a> ()</td></tr>
<tr class="memdesc:a06f0c412f74f3b538efac94886005b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes reading the current node.  <br /></td></tr>
<tr class="separator:a06f0c412f74f3b538efac94886005b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acba55850d08642d1c5532c91eb360325" id="r_acba55850d08642d1c5532c91eb360325"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acba55850d08642d1c5532c91eb360325">getNodeName</a> () const</td></tr>
<tr class="separator:acba55850d08642d1c5532c91eb360325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3303435877555d5d5366ee654eb24f60" id="r_a3303435877555d5d5366ee654eb24f60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3303435877555d5d5366ee654eb24f60">setNextName</a> (const char *name)</td></tr>
<tr class="memdesc:a3303435877555d5d5366ee654eb24f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the name for the next node created with startNode.  <br /></td></tr>
<tr class="separator:a3303435877555d5d5366ee654eb24f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6c82e07be922011364cb0d74df70a4" id="r_acd6c82e07be922011364cb0d74df70a4"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt; std::is_unsigned&lt; T &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, std::is_same&lt; T, bool &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a> &gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:acd6c82e07be922011364cb0d74df70a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd6c82e07be922011364cb0d74df70a4">loadValue</a> (T &amp;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>)</td></tr>
<tr class="memdesc:acd6c82e07be922011364cb0d74df70a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a bool from the current top node.  <br /></td></tr>
<tr class="separator:acd6c82e07be922011364cb0d74df70a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6c82e07be922011364cb0d74df70a4" id="r_acd6c82e07be922011364cb0d74df70a4"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt; std::is_integral&lt; T &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, !std::is_same&lt; T, bool &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, sizeof(T)==sizeof(char)&gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:acd6c82e07be922011364cb0d74df70a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd6c82e07be922011364cb0d74df70a4">loadValue</a> (T &amp;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>)</td></tr>
<tr class="memdesc:acd6c82e07be922011364cb0d74df70a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a char (signed or unsigned) from the current top node.  <br /></td></tr>
<tr class="separator:acd6c82e07be922011364cb0d74df70a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdbedad1accc2982d3e8261e7510d6c" id="r_a2fdbedad1accc2982d3e8261e7510d6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fdbedad1accc2982d3e8261e7510d6c">loadValue</a> (<a class="el" href="stdint_8h.html#aef44329758059c91c76d334e8fc09700">int8_t</a> &amp;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>)</td></tr>
<tr class="memdesc:a2fdbedad1accc2982d3e8261e7510d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load an int8_t from the current top node (ensures we parse entire number)  <br /></td></tr>
<tr class="separator:a2fdbedad1accc2982d3e8261e7510d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d2453dc4bf78cd48b227f7bdbf1448" id="r_af0d2453dc4bf78cd48b227f7bdbf1448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0d2453dc4bf78cd48b227f7bdbf1448">loadValue</a> (<a class="el" href="stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> &amp;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>)</td></tr>
<tr class="memdesc:af0d2453dc4bf78cd48b227f7bdbf1448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a uint8_t from the current top node (ensures we parse entire number)  <br /></td></tr>
<tr class="separator:af0d2453dc4bf78cd48b227f7bdbf1448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6c82e07be922011364cb0d74df70a4" id="r_acd6c82e07be922011364cb0d74df70a4"><td class="memTemplParams" colspan="2">template&lt;class T , traits::EnableIf&lt; std::is_unsigned&lt; T &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, !std::is_same&lt; T, bool &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, !std::is_same&lt; T, char &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, !std::is_same&lt; T, unsigned char &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, sizeof(T)&lt; sizeof(long long)&gt;=traits::sfinae &gt; inline void loadValue(T &amp;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>) { <a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>=static_cast&lt; T &gt;(std::stoul(itsNodes.top().node-&gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>()));} template&lt; class T, traits::EnableIf&lt; std::is_unsigned&lt; T &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, !std::is_same&lt; T, bool &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, sizeof(T) &gt;=sizeof(long long)&gt;  = traits::sfinae&gt; </td></tr>
<tr class="memitem:acd6c82e07be922011364cb0d74df70a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd6c82e07be922011364cb0d74df70a4">loadValue</a> (T &amp;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>)</td></tr>
<tr class="memdesc:acd6c82e07be922011364cb0d74df70a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a type best represented as an unsigned long from the current top node.  <br /></td></tr>
<tr class="separator:acd6c82e07be922011364cb0d74df70a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509e86ad2b916f548f0efc47c83f7976" id="r_a509e86ad2b916f548f0efc47c83f7976"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a509e86ad2b916f548f0efc47c83f7976">if</a> (std::fpclassify(<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>) !=FP_SUBNORMAL) throw</td></tr>
<tr class="separator:a509e86ad2b916f548f0efc47c83f7976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703207c2e0bc195ebd8ba8e81170ad7d" id="r_a703207c2e0bc195ebd8ba8e81170ad7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a703207c2e0bc195ebd8ba8e81170ad7d">loadValue</a> (long double &amp;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>)</td></tr>
<tr class="memdesc:a703207c2e0bc195ebd8ba8e81170ad7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a type best represented as a long double from the current top node.  <br /></td></tr>
<tr class="separator:a703207c2e0bc195ebd8ba8e81170ad7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5874ffacb2c44546e71819cc23f7040e" id="r_a5874ffacb2c44546e71819cc23f7040e"><td class="memTemplParams" colspan="2">template&lt;class CharT , class Traits , class Alloc &gt; </td></tr>
<tr class="memitem:a5874ffacb2c44546e71819cc23f7040e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5874ffacb2c44546e71819cc23f7040e">loadValue</a> (std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;str)</td></tr>
<tr class="memdesc:a5874ffacb2c44546e71819cc23f7040e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a string from the current node from the current top node.  <br /></td></tr>
<tr class="separator:a5874ffacb2c44546e71819cc23f7040e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ed2b9bd88b279e999b4df1f3f129f8" id="r_ad9ed2b9bd88b279e999b4df1f3f129f8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad9ed2b9bd88b279e999b4df1f3f129f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad9ed2b9bd88b279e999b4df1f3f129f8">loadSize</a> (T &amp;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>)</td></tr>
<tr class="memdesc:ad9ed2b9bd88b279e999b4df1f3f129f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the size of the current top node.  <br /></td></tr>
<tr class="separator:ad9ed2b9bd88b279e999b4df1f3f129f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e396aeced2f05e4d76b0e4c7ef3f25d" id="r_a1e396aeced2f05e4d76b0e4c7ef3f25d"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e396aeced2f05e4d76b0e4c7ef3f25d">getNumChildren</a> (<a class="el" href="classcereal_1_1rapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt;&gt; *node)</td></tr>
<tr class="memdesc:a1e396aeced2f05e4d76b0e4c7ef3f25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of children (usually interpreted as size) for the specified node.  <br /></td></tr>
<tr class="separator:a1e396aeced2f05e4d76b0e4c7ef3f25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classcereal_1_1_input_archive"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classcereal_1_1_input_archive')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classcereal_1_1_input_archive.html">cereal::InputArchive&lt; XMLInputArchive &gt;</a></td></tr>
<tr class="memitem:adeb555e9b25f21391e4cc9eca9f04dbd inherit pub_types_classcereal_1_1_input_archive" id="r_adeb555e9b25f21391e4cc9eca9f04dbd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_input_archive.html#adeb555e9b25f21391e4cc9eca9f04dbd">is_loading</a></td></tr>
<tr class="memdesc:adeb555e9b25f21391e4cc9eca9f04dbd inherit pub_types_classcereal_1_1_input_archive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates this archive is intended for loading.  <br /></td></tr>
<tr class="separator:adeb555e9b25f21391e4cc9eca9f04dbd inherit pub_types_classcereal_1_1_input_archive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90a8d1dc2c9163367765817f7b704d4 inherit pub_types_classcereal_1_1_input_archive" id="r_af90a8d1dc2c9163367765817f7b704d4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcereal_1_1_input_archive.html#af90a8d1dc2c9163367765817f7b704d4">is_saving</a></td></tr>
<tr class="memdesc:af90a8d1dc2c9163367765817f7b704d4 inherit pub_types_classcereal_1_1_input_archive"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates this archive is not intended for saving.  <br /></td></tr>
<tr class="separator:af90a8d1dc2c9163367765817f7b704d4 inherit pub_types_classcereal_1_1_input_archive"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An output archive designed to load data from XML. </p>
<p>This archive uses RapidXML to build an in memory XML tree of the data in the stream it is given before loading any types serialized.</p>
<p>As with the output XML archive, the preferred way to use this archive is in an RAII fashion, ensuring its destruction after all data has been read.</p>
<p>Input XML should have been produced by the <a class="el" href="classcereal_1_1_x_m_l_output_archive.html" title="An output archive designed to save data to XML.">XMLOutputArchive</a>. Data can only be added to dynamically sized containers - the input archive will determine their size by looking at the number of child nodes. Data that did not originate from an <a class="el" href="classcereal_1_1_x_m_l_output_archive.html" title="An output archive designed to save data to XML.">XMLOutputArchive</a> is not officially supported, but may be possible to use if properly formatted.</p>
<p>The <a class="el" href="classcereal_1_1_x_m_l_input_archive.html" title="An output archive designed to load data from XML.">XMLInputArchive</a> does not require that nodes are loaded in the same order they were saved by <a class="el" href="classcereal_1_1_x_m_l_output_archive.html" title="An output archive designed to save data to XML.">XMLOutputArchive</a>. Using name value pairs (NVPs), it is possible to load in an out of order fashion or otherwise skip/select specific nodes to load.</p>
<p>The default behavior of the input archive is to read sequentially starting with the first node and exploring its children. When a given NVP does not match the read in name for a node, the archive will search for that node at the current level and load it if it exists. After loading an out of order node, the archive will then proceed back to loading sequentially from its new position.</p>
<p>Consider this simple example where loading of some data is skipped:</p>
<div class="fragment"><div class="line"><span class="comment">// imagine the input file has someData(1-9) saved in order at the top level node</span></div>
<div class="line">ar( someData1, someData2, someData3 );        <span class="comment">// XML loads in the order it sees in the file</span></div>
<div class="line">ar( cereal::make_nvp( <span class="stringliteral">&quot;hello&quot;</span>, someData6 ) ); <span class="comment">// NVP given does not</span></div>
<div class="line">                                              <span class="comment">// match expected NVP name, so we search</span></div>
<div class="line">                                              <span class="comment">// for the given NVP and load that value</span></div>
<div class="line">ar( someData7, someData8, someData9 );        <span class="comment">// with no NVP given, loading resumes at its</span></div>
<div class="line">                                              <span class="comment">// current location, proceeding sequentially</span></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab641ded4033d8e998e41dd002ece9184" name="ab641ded4033d8e998e41dd002ece9184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab641ded4033d8e998e41dd002ece9184">&#9670;&#160;</a></span>XMLInputArchive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cereal::XMLInputArchive::XMLInputArchive </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct, reading in from the provided stream. </p>
<p>Reads in an entire XML document from some stream and parses it as soon as serialization starts</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream to read from. Can be a stringstream or a file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbe95a5639def701ef58187ac9190868" name="adbe95a5639def701ef58187ac9190868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe95a5639def701ef58187ac9190868">&#9670;&#160;</a></span>~XMLInputArchive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cereal::XMLInputArchive::~XMLInputArchive </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a06f0c412f74f3b538efac94886005b44" name="a06f0c412f74f3b538efac94886005b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f0c412f74f3b538efac94886005b44">&#9670;&#160;</a></span>finishNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::XMLInputArchive::finishNode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finishes reading the current node. </p>

</div>
</div>
<a id="acba55850d08642d1c5532c91eb360325" name="acba55850d08642d1c5532c91eb360325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acba55850d08642d1c5532c91eb360325">&#9670;&#160;</a></span>getNodeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * cereal::XMLInputArchive::getNodeName </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves the current node name will return <code>nullptr</code> if the node does not have a name </p>

</div>
</div>
<a id="a1e396aeced2f05e4d76b0e4c7ef3f25d" name="a1e396aeced2f05e4d76b0e4c7ef3f25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e396aeced2f05e4d76b0e4c7ef3f25d">&#9670;&#160;</a></span>getNumChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t cereal::XMLInputArchive::getNumChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcereal_1_1rapidxml_1_1xml__node.html">rapidxml::xml_node</a>&lt;&gt; *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of children (usually interpreted as size) for the specified node. </p>

</div>
</div>
<a id="a509e86ad2b916f548f0efc47c83f7976" name="a509e86ad2b916f548f0efc47c83f7976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509e86ad2b916f548f0efc47c83f7976">&#9670;&#160;</a></span>if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cereal::XMLInputArchive::if </td>
          <td>(</td>
          <td class="paramtype">std::fpclassify(<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>) !</td>          <td class="paramname"><span class="paramname"><span class="paramdefsep"> = </span><span class="paramdefval">FP_SUBNORMAL</span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a974ecacf6a6411fb98e89182011b4b55" name="a974ecacf6a6411fb98e89182011b4b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a974ecacf6a6411fb98e89182011b4b55">&#9670;&#160;</a></span>loadBinaryValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::XMLInputArchive::loadBinaryValue </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads some binary data, encoded as a <a class="el" href="namespacecereal_1_1base64.html">base64</a> string, optionally specified by some name. </p>
<p>This will automatically start and finish a node to load the data, and can be called directly by users.</p>
<p>Note that this follows the same ordering rules specified in the class description in regards to loading in/out of order </p>

</div>
</div>
<a id="ad9ed2b9bd88b279e999b4df1f3f129f8" name="ad9ed2b9bd88b279e999b4df1f3f129f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ed2b9bd88b279e999b4df1f3f129f8">&#9670;&#160;</a></span>loadSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::XMLInputArchive::loadSize </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads the size of the current top node. </p>

</div>
</div>
<a id="a2fdbedad1accc2982d3e8261e7510d6c" name="a2fdbedad1accc2982d3e8261e7510d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdbedad1accc2982d3e8261e7510d6c">&#9670;&#160;</a></span>loadValue() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::XMLInputArchive::loadValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#aef44329758059c91c76d334e8fc09700">int8_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load an int8_t from the current top node (ensures we parse entire number) </p>

</div>
</div>
<a id="a703207c2e0bc195ebd8ba8e81170ad7d" name="a703207c2e0bc195ebd8ba8e81170ad7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703207c2e0bc195ebd8ba8e81170ad7d">&#9670;&#160;</a></span>loadValue() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::XMLInputArchive::loadValue </td>
          <td>(</td>
          <td class="paramtype">long double &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a type best represented as a long double from the current top node. </p>

</div>
</div>
<a id="a5874ffacb2c44546e71819cc23f7040e" name="a5874ffacb2c44546e71819cc23f7040e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5874ffacb2c44546e71819cc23f7040e">&#9670;&#160;</a></span>loadValue() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CharT , class Traits , class Alloc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::XMLInputArchive::loadValue </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; CharT, Traits, Alloc &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a string from the current node from the current top node. </p>

</div>
</div>
<a id="acd6c82e07be922011364cb0d74df70a4" name="acd6c82e07be922011364cb0d74df70a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6c82e07be922011364cb0d74df70a4">&#9670;&#160;</a></span>loadValue() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt; std::is_unsigned&lt; T &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, std::is_same&lt; T, bool &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a> &gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::XMLInputArchive::loadValue </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a bool from the current top node. </p>

</div>
</div>
<a id="acd6c82e07be922011364cb0d74df70a4" name="acd6c82e07be922011364cb0d74df70a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6c82e07be922011364cb0d74df70a4">&#9670;&#160;</a></span>loadValue() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt; std::is_integral&lt; T &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, !std::is_same&lt; T, bool &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, sizeof(T)==sizeof(char)&gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::XMLInputArchive::loadValue </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a char (signed or unsigned) from the current top node. </p>

</div>
</div>
<a id="acd6c82e07be922011364cb0d74df70a4" name="acd6c82e07be922011364cb0d74df70a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6c82e07be922011364cb0d74df70a4">&#9670;&#160;</a></span>loadValue() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , traits::EnableIf&lt; std::is_unsigned&lt; T &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, !std::is_same&lt; T, bool &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, !std::is_same&lt; T, char &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, !std::is_same&lt; T, unsigned char &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, sizeof(T)&lt; sizeof(long long)&gt;=traits::sfinae &gt; inline void loadValue(T &amp;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>) { <a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>=static_cast&lt; T &gt;(std::stoul(itsNodes.top().node-&gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">value</a>()));} template&lt; class T, traits::EnableIf&lt; std::is_unsigned&lt; T &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, !std::is_same&lt; T, bool &gt;<a class="el" href="#acd31f5302f9d5d9046b4b1425e370fc6">::value</a>, sizeof(T) &gt;=sizeof(long long)&gt;  = traits::sfinae&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::XMLInputArchive::loadValue </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loads a type best represented as an unsigned long from the current top node. </p>

</div>
</div>
<a id="af0d2453dc4bf78cd48b227f7bdbf1448" name="af0d2453dc4bf78cd48b227f7bdbf1448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0d2453dc4bf78cd48b227f7bdbf1448">&#9670;&#160;</a></span>loadValue() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::XMLInputArchive::loadValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#aba7bc1797add20fe3efdf37ced1182c5">uint8_t</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a uint8_t from the current top node (ensures we parse entire number) </p>

</div>
</div>
<a id="a3303435877555d5d5366ee654eb24f60" name="a3303435877555d5d5366ee654eb24f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3303435877555d5d5366ee654eb24f60">&#9670;&#160;</a></span>setNextName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::XMLInputArchive::setNextName </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the name for the next node created with startNode. </p>

</div>
</div>
<a id="a96c8399e6e6651126aaf5d38631c14d0" name="a96c8399e6e6651126aaf5d38631c14d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c8399e6e6651126aaf5d38631c14d0">&#9670;&#160;</a></span>startNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cereal::XMLInputArchive::startNode </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepares to start reading the next node. </p>
<p>This places the next node to be parsed onto the nodes stack.</p>
<p>By default our strategy is to start with the document root node and then recursively iterate through all children in the order they show up in the document. We don't need to know NVPs do to this; we'll just blindly load in the order things appear in.</p>
<p>We check to see if the specified NVP matches what the next automatically loaded node is. If they match, we just continue as normal, going in order. If they don't match, we attempt to find a node named after the NVP that is being loaded. If that NVP does not exist, we throw an exception. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acd31f5302f9d5d9046b4b1425e370fc6" name="acd31f5302f9d5d9046b4b1425e370fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd31f5302f9d5d9046b4b1425e370fc6">&#9670;&#160;</a></span>value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cereal::XMLInputArchive::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a type best represented as an int from the current top node. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>//192.168.77.68/ai2/zhzhi/github/video_pipe_c/third_party/cereal/archives/<a class="el" href="xml_8hpp_source.html">xml.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
